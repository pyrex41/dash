This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-12-14T23:21:57.962Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
elm-stuff/
  generated-code/
    elm-community/
      elm-test/
        0.19.1-revision7/
          dependencies.7ed8010665012120200c83bf1a6655a3e9f66a5049b84c377dc07fcbbec7dc56.json
          dependencies.ea4acb9e915cd8e5c1e9a5997edd6e73ec9f754933a0bd0644eef92e600772d3.json
          elm.json
public/
  vite.svg
src/
  db/
    index.ts
    schema.ts
  counter.ts
  Dashboard.elm
  main.ts
  style.css
  typescript.svg
  vite-env.d.ts
.gitignore
drizzle.config.ts
elm.json
index.html
package.json
postcss.config.cjs
tailwind.config.js
tsconfig.json
vite.config.ts

================================================================
Repository Files
================================================================

================
File: elm-stuff/generated-code/elm-community/elm-test/0.19.1-revision7/dependencies.7ed8010665012120200c83bf1a6655a3e9f66a5049b84c377dc07fcbbec7dc56.json
================
{"direct":{"elm/browser":"1.0.2","elm/core":"1.0.5","elm/html":"1.0.0","elm/json":"1.1.3","elm/random":"1.0.0","elm/time":"1.0.0"},"indirect":{"elm/url":"1.0.0","elm/virtual-dom":"1.0.3"}}

================
File: elm-stuff/generated-code/elm-community/elm-test/0.19.1-revision7/dependencies.ea4acb9e915cd8e5c1e9a5997edd6e73ec9f754933a0bd0644eef92e600772d3.json
================
{"direct":{"NoRedInk/elm-json-decode-pipeline":"1.0.1","elm/browser":"1.0.2","elm/core":"1.0.5","elm/html":"1.0.0","elm/json":"1.1.3","elm/random":"1.0.0","elm/time":"1.0.0"},"indirect":{"elm/url":"1.0.0","elm/virtual-dom":"1.0.3"}}

================
File: elm-stuff/generated-code/elm-community/elm-test/0.19.1-revision7/elm.json
================
{
    "type": "application",
    "source-directories": [
        "src",
        "../../../../../../.config/yarn/global/node_modules/elm-test/elm/src",
        "../../../../../src"
    ],
    "elm-version": "0.19.1",
    "dependencies": {
        "direct": {
            "NoRedInk/elm-json-decode-pipeline": "1.0.1",
            "elm/browser": "1.0.2",
            "elm/core": "1.0.5",
            "elm/html": "1.0.0",
            "elm/json": "1.1.3",
            "elm/random": "1.0.0",
            "elm/time": "1.0.0"
        },
        "indirect": {
            "elm/url": "1.0.0",
            "elm/virtual-dom": "1.0.3"
        }
    },
    "test-dependencies": {
        "direct": {},
        "indirect": {}
    }
}

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: src/db/index.ts
================
import { drizzle } from 'drizzle-orm/libsql';

export const db = drizzle({ connection: {
  url: import.meta.env.VITE_TURSO_DATABASE_URL,
  authToken: import.meta.env.VITE_TURSO_AUTH_TOKEN,
}});

================
File: src/db/schema.ts
================
// /server/db/schema.ts
import { sql } from 'drizzle-orm';
import { sqliteTable, text, integer, unique, index } from 'drizzle-orm/sqlite-core';

export const user = sqliteTable('user', {
  id: text('id').primaryKey().notNull(),
  createdAt: integer('createdAt', { mode: 'timestamp' })
    .default(sql`(CURRENT_TIMESTAMP)`)
    .notNull(),
  updatedAt: integer('updatedAt', { mode: 'timestamp' })
    .default(sql`(CURRENT_TIMESTAMP)`)
    .notNull(),
  email: text('email'),
  isTemporary: integer('is_temporary', { mode: 'boolean' }).notNull().default(true),
  isAnonymous: integer('is_anonymous', { mode: 'boolean' }).notNull().default(true),
});

export const applications = sqliteTable(
  'applications',
  {
    id: text('id').primaryKey().notNull(),
    userId: text('user_id')
      .notNull()
      .references(() => user.id),
    status: text('status').notNull(),
    createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
    updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull(),
    data: text('data', { mode: 'json' }).$type<Record<string, any>>().notNull(),
    name: text('name'),
    naic: text('naic'),
    zip: text('zip').notNull(),
    county: text('county').notNull(),
    dob: text('dob').notNull(),
    schema: text('schema', { mode: 'json' }).$type<Record<string, any>>().notNull(),
    originalSchema: text('original_schema', { mode: 'json' }).$type<Record<string, any>>().notNull(),
    underwritingType: integer('underwriting_type').notNull().default(0),
  },
  (table) => ({
    csgKeyIndex: index('idx_applications_csg_key').on(table.id),
    underwritingTypeCheck: sql`CHECK (underwriting_type IN (0, 1, 2))`
  })
);

export const csgApplications = sqliteTable(
  'csg_applications',
  {
    id: integer('id').primaryKey({ autoIncrement: true }),
    applicationId: text('application_id')
      .notNull()
      .references(() => applications.id),
    key: text('key').notNull(),
    responseBody: text('response_body').notNull(),
    brokerEmail: text('broker_email'),
    createdAt: integer('created_at', { mode: 'timestamp' })
      .notNull()
      .default(sql`CURRENT_TIMESTAMP`),
    updatedAt: integer('updated_at', { mode: 'timestamp' })
      .notNull()
      .default(sql`CURRENT_TIMESTAMP`),
  },
  (table) => ({
    applicationIdIndex: index('idx_csg_applications_application_id').on(table.applicationId),
    keyIndex: index('idx_csg_applications_key').on(table.key),
  })
);

export const onboarding = sqliteTable('onboarding', {
  id: text('id').primaryKey(),
  userId: text('user_id')
    .notNull()
    .references(() => user.id),
  createdAt: integer('created_at', { mode: 'timestamp' })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
  updatedAt: integer('updated_at', { mode: 'timestamp' })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
  data: text('data', { mode: 'json' }).notNull(),
});

export const csgTokens = sqliteTable('csg_tokens', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  token: text('token').notNull(),
  expiresAt: integer('expires_at', { mode: 'timestamp' }).notNull(),
  createdAt: integer('created_at', { mode: 'timestamp' })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
  updatedAt: integer('updated_at', { mode: 'timestamp' })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
}, (table) => ({
  tokenIndex: index('idx_csg_tokens_token').on(table.token),
  expiresAtIndex: index('idx_csg_tokens_expires_at').on(table.expiresAt),
}));

export const brokers = sqliteTable('brokers', {
  id: text('id').primaryKey(),
  username: text('username').notNull().unique(),
  passwordHash: text('password_hash').notNull(),
  createdAt: integer('created_at', { mode: 'timestamp' })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
  updatedAt: integer('updated_at', { mode: 'timestamp' })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
});

export const bookings = sqliteTable('bookings', {
  id: text('id').primaryKey().notNull(),
  userId: text('user_id')
    .references(() => user.id),
  applicationId: text('application_id')
    .references(() => applications.id),
  email: text('email').notNull(),
  phone: text('phone'),
  url: text('url').notNull(),
  event: text('event'),
  status: text('status').notNull(),
  createdAt: text('created_at')
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
  updatedAt: text('updated_at')
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
}, (table) => ({
  userIdIndex: index('idx_bookings_user_id').on(table.userId),
  emailIndex: index('idx_bookings_email').on(table.email),
  applicationIdIndex: index('idx_bookings_application_id').on(table.applicationId),
}));

================
File: src/counter.ts
================
export function setupCounter(element: HTMLButtonElement) {
  let counter = 0
  const setCounter = (count: number) => {
    counter = count
    element.innerHTML = `count is ${counter}`
  }
  element.addEventListener('click', () => setCounter(counter + 1))
  setCounter(0)
}

================
File: src/Dashboard.elm
================
port module Dashboard exposing (Model, Msg, init, update, view)

import Browser
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Json.Decode as Decode
import Json.Decode.Pipeline as Pipeline



-- PORTS


type alias PaginationInfo =
    { total : Int
    , page : Int
    , pageSize : Int
    , totalPages : Int
    }


type alias ApplicationsResponse =
    { applications : List Application
    , pagination : PaginationInfo
    }


port receiveApplications : (Decode.Value -> msg) -> Sub msg


port requestRefresh : { page : Int, pageSize : Int } -> Cmd msg


port exportToCsv : { searchTerm : String, hasContactFilter : Bool, hasCSGFilter : Bool } -> Cmd msg



-- MAIN


main =
    Browser.element
        { init = init
        , update = update
        , subscriptions = subscriptions
        , view = view
        }



-- MODEL


type alias Model =
    { quoteSent : Int
    , submissions : Int
    , waitingReview : Int
    , completedApps : Int
    , applications : List Application
    , searchTerm : String
    , hasContactFilter : Bool
    , hasCSGFilter : Bool
    , isLoading : Bool
    , error : Maybe String
    }


type alias Application =
    { id : String
    , userId : String
    , userEmail : Maybe String
    , createdAt : String
    , dateSubmitted : String
    , dateCompleted : String
    , status : Status
    , state : Maybe String
    , data : Decode.Value
    , carrier : String
    , booking : Maybe Booking
    }


type alias Booking =
    { email : String
    , phone : Maybe String
    }


type Status
    = CompletedApp
    | WaitingReview
    | QuoteSent



-- INIT


init : () -> ( Model, Cmd Msg )
init _ =
    ( { quoteSent = 0
      , submissions = 0
      , waitingReview = 0
      , completedApps = 0
      , applications = []
      , searchTerm = ""
      , hasContactFilter = False
      , hasCSGFilter = False
      , isLoading = True
      , error = Nothing
      }
    , requestRefresh { page = 0, pageSize = 20 }
    )



-- UPDATE


type Msg
    = NoOp
    | ViewApplication String
    | CompleteApplication String
    | SearchTermChanged String
    | ToggleContactFilter Bool
    | ToggleCSGFilter Bool
    | RefreshApplications
    | ApplicationsReceived (Result Decode.Error ApplicationsResponse)
    | ExportToCsv


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        NoOp ->
            ( model, Cmd.none )

        ViewApplication id ->
            ( model, Cmd.none )

        CompleteApplication id ->
            ( model, Cmd.none )

        SearchTermChanged term ->
            ( { model | searchTerm = term }, Cmd.none )

        ToggleContactFilter value ->
            ( { model | hasContactFilter = value }, Cmd.none )

        ToggleCSGFilter value ->
            ( { model | hasCSGFilter = value }, Cmd.none )

        RefreshApplications ->
            ( { model | isLoading = True }, requestRefresh { page = 0, pageSize = 20 } )

        ApplicationsReceived (Ok response) ->
            ( { model
                | applications = response.applications
                , isLoading = False
                , quoteSent = List.length (List.filter (\a -> a.status == QuoteSent) response.applications)
                , submissions = List.length (List.filter (\a -> a.status == QuoteSent) response.applications)
                , waitingReview = List.length (List.filter (\a -> a.status == WaitingReview) response.applications)
                , completedApps = List.length (List.filter (\a -> a.status == CompletedApp) response.applications)
              }
            , Cmd.none
            )

        ApplicationsReceived (Err _) ->
            ( { model | error = Just "Failed to load applications", isLoading = False }, Cmd.none )

        ExportToCsv ->
            ( model
            , exportToCsv
                { searchTerm = model.searchTerm
                , hasContactFilter = model.hasContactFilter
                , hasCSGFilter = model.hasCSGFilter
                }
            )



-- Add completion logic here
-- VIEW


view : Model -> Html Msg
view model =
    div [ class "min-h-screen bg-white" ]
        [ viewHeader
        , div [ class "max-w-7xl mx-auto" ]
            [ viewMetrics model
            , viewApplications model
            ]
        ]


viewHeader : Html Msg
viewHeader =
    header [ class "border-b" ]
        [ div [ class "max-w-7xl mx-auto flex justify-between items-center p-4" ]
            [ div [ class "flex items-center gap-4" ]
                [ h1 [ class "text-xl font-bold" ] [ text "White Labeled Logo" ]
                , nav [ class "flex gap-4" ]
                    [ a [ href "#" ] [ text "Medigap Applications" ]
                    , a [ href "#" ] [ text "Contacts" ]
                    ]
                ]
            , div [ class "flex items-center gap-4" ]
                [ button [ class "bg-black text-white px-4 py-2 rounded" ]
                    [ text "Send Something" ]
                , div [ class "flex items-center gap-2" ]
                    [ span [ class "w-8 h-8 bg-gray-200 rounded-full flex items-center justify-center" ]
                        [ text "J" ]
                    , text "John Doe"
                    ]
                ]
            ]
        ]


viewMetrics : Model -> Html Msg
viewMetrics model =
    div [ class "grid grid-cols-4 gap-4 p-4" ]
        [ viewMetricCard "Quote Sent" model.quoteSent "80" "up"
        , viewMetricCard "Submissions" model.submissions "20" "up"
        , viewMetricCard "Waiting Review" model.waitingReview "10" "down"
        , viewMetricCard "Completed Apps" model.completedApps "" ""
        ]


viewMetricCard : String -> Int -> String -> String -> Html Msg
viewMetricCard title value percentage direction =
    div [ class "p-4 rounded-lg border" ]
        [ div [ class "text-sm text-gray-600" ] [ text title ]
        , div [ class "text-3xl font-bold" ] [ text (String.fromInt value) ]
        , if percentage /= "" then
            div
                [ class
                    ("text-sm "
                        ++ (if direction == "up" then
                                "text-green-500"

                            else
                                "text-red-500"
                           )
                    )
                ]
                [ text (percentage ++ "% vs last month") ]

          else
            text ""
        ]


viewApplications : Model -> Html Msg
viewApplications model =
    div [ class "p-4" ]
        [ div [ class "flex justify-between items-center mb-4" ]
            [ h2 [ class "text-xl" ] [ text "Applications" ]
            , div [ class "flex gap-2" ]
                [ button [ class "px-3 py-1 border rounded flex items-center gap-2" ]
                    [ text "Filter"
                    ]
                , input
                    [ class "px-3 py-1 border rounded"
                    , placeholder "Search"
                    , type_ "search"
                    ]
                    []
                ]
            ]
        , if model.isLoading then
            div [ class "flex justify-center items-center py-8" ]
                [ div [ class "animate-spin rounded-full h-12 w-12 border-b-2 border-purple-600" ] []
                , span [ class "sr-only" ] [ text "Loading..." ]
                ]

          else
            table [ class "w-full border-collapse" ]
                [ thead []
                    [ tr [ class "border-b text-left" ]
                        [ th [ class "w-8 py-3 px-4" ]
                            [ input [ type_ "checkbox", class "rounded border-gray-300" ] [] ]
                        , th [ class "py-3 px-4 font-medium text-sm text-gray-600" ] [ text "Name" ]
                        , th [ class "py-3 px-4 font-medium text-sm text-gray-600" ] [ text "Carrier" ]
                        , th [ class "py-3 px-4 font-medium text-sm text-gray-600" ] [ text "Status" ]
                        , th [ class "py-3 px-4 font-medium text-sm text-gray-600" ] [ text "Phone Number" ]
                        , th [ class "py-3 px-4 font-medium text-sm text-gray-600" ] [ text "Email address" ]
                        , th [ class "py-3 px-4 font-medium text-sm text-gray-600" ] [ text "Date Submitted" ]
                        , th [ class "py-3 px-4 font-medium text-sm text-gray-600" ] [ text "Date Completed" ]
                        , th [ class "py-3 px-4 font-medium text-sm text-gray-600" ] [ text "Process Actions" ]
                        , th [ class "py-3 px-4 font-medium text-sm text-gray-600" ] [ text "Actions" ]
                        ]
                    ]
                , tbody []
                    (List.map viewApplicationRow model.applications)
                ]
        ]


viewApplicationRow : Application -> Html Msg
viewApplicationRow app =
    let
        getName =
            let
                firstName =
                    app.data
                        |> Decode.decodeValue (Decode.at [ "applicant_info", "f_name" ] Decode.string)
                        |> Result.toMaybe
                        |> Maybe.withDefault ""

                lastName =
                    app.data
                        |> Decode.decodeValue (Decode.at [ "applicant_info", "l_name" ] Decode.string)
                        |> Result.toMaybe
                        |> Maybe.withDefault ""
            in
            String.trim (firstName ++ " " ++ lastName)

        getApplicantInfo field =
            app.data
                |> Decode.decodeValue (Decode.at [ "applicant_info", field ] Decode.string)
                |> Result.toMaybe

        getEmail =
            [ app.userEmail -- From user
            , getApplicantInfo "email" -- From application data
            , Maybe.map .email app.booking -- From booking
            ]
                |> List.filterMap identity
                |> List.head
                |> Maybe.withDefault ""

        getPhone =
            [ getApplicantInfo "phone" -- From application data
            , Maybe.andThen .phone app.booking -- From booking
            ]
                |> List.filterMap identity
                |> List.head
                |> Maybe.withDefault ""

        formatDate dateString =
            dateString
                |> String.split "T"
                |> List.head
                |> Maybe.withDefault dateString
    in
    tr [ class "border-b hover:bg-gray-50" ]
        [ td [ class "py-3 px-4" ]
            [ input [ type_ "checkbox", class "rounded border-gray-300" ] [] ]
        , td [ class "py-3 px-4" ] [ text getName ]
        , td [ class "py-3 px-4" ] [ text app.carrier ]
        , td [ class "py-3 px-4" ] [ viewStatus app.status ]
        , td [ class "py-3 px-4 text-gray-600" ] [ text getPhone ]
        , td [ class "py-3 px-4 text-gray-600" ] [ text getEmail ]
        , td [ class "py-3 px-4 text-gray-600" ] [ text (formatDate app.dateSubmitted) ]
        , td [ class "py-3 px-4 text-gray-600" ] [ text (formatDate app.dateCompleted) ]
        , td [ class "py-3 px-4" ]
            [ button
                [ class "bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-md text-sm"
                , onClick (ViewApplication app.id)
                ]
                [ text "View Application" ]
            ]
        , td [ class "py-3 px-4" ]
            [ div [ class "flex gap-2" ]
                [ button [ class "text-gray-400 hover:text-gray-600" ]
                    [ text "📋" ]

                -- Copy icon
                , button [ class "text-gray-400 hover:text-gray-600" ]
                    [ text "🗑" ]

                -- Delete icon
                ]
            ]
        ]


viewStatus : Status -> Html Msg
viewStatus status =
    let
        ( statusText, statusColor ) =
            case status of
                CompletedApp ->
                    ( "Completed App", "text-green-600 bg-green-50" )

                WaitingReview ->
                    ( "Waiting Review", "text-red-600 bg-red-50" )

                QuoteSent ->
                    ( "Quote Sent", "text-blue-600 bg-blue-50" )
    in
    div [ class ("flex items-center gap-2 " ++ statusColor ++ " px-3 py-1 rounded-full w-fit") ]
        [ div [ class "w-2 h-2 rounded-full bg-current" ] []
        , span [ class "text-sm" ] [ text statusText ]
        ]



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions _ =
    receiveApplications
        (Decode.decodeValue applicationListDecoder >> ApplicationsReceived)



-- DECODERS
{--
jdebug : String -> Decode.Decoder a -> Decode.Decoder a
jdebug message decoder =
    Decode.value
        |> Decode.andThen (debugHelper message decoder)


debugHelper : String -> Decode.Decoder a -> Decode.Value -> Decode.Decoder a
debugHelper message decoder value =
    let
        _ =
            Debug.log message (Decode.decodeValue decoder value)
    in
    decoder
--}


applicationDecoder : Decode.Decoder Application
applicationDecoder =
    Decode.succeed Application
        |> Pipeline.required "id" Decode.string
        |> Pipeline.required "userId" Decode.string
        |> Pipeline.optional "userEmail" (Decode.nullable Decode.string) Nothing
        |> Pipeline.required "createdAt" Decode.string
        |> Pipeline.required "dateSubmitted" Decode.string
        |> Pipeline.required "dateCompleted" Decode.string
        |> Pipeline.required "status" statusDecoder
        |> Pipeline.optional "state" (Decode.nullable Decode.string) Nothing
        |> Pipeline.required "data" Decode.value
        |> Pipeline.required "name" (Decode.map cleanCarrierName Decode.string)
        |> Pipeline.optional "booking" (Decode.nullable bookingDecoder) Nothing



-- |> jdebug "Application Decoder"


applicationListDecoder : Decode.Decoder ApplicationsResponse
applicationListDecoder =
    Decode.map2 ApplicationsResponse
        (Decode.field "applications" (Decode.list applicationDecoder))
        (Decode.field "pagination" paginationDecoder)



-- |> jdebug "Application List Decoder"


paginationDecoder : Decode.Decoder PaginationInfo
paginationDecoder =
    Decode.map4 PaginationInfo
        (Decode.field "total" Decode.int)
        (Decode.field "page" Decode.int)
        (Decode.field "pageSize" Decode.int)
        (Decode.field "totalPages" Decode.int)



-- |> jdebug "Pagination Decoder"


statusDecoder : Decode.Decoder Status
statusDecoder =
    Decode.string
        |> Decode.andThen
            (\str ->
                case str of
                    "completed" ->
                        Decode.succeed CompletedApp

                    "review" ->
                        Decode.succeed WaitingReview

                    "quote" ->
                        Decode.succeed QuoteSent

                    _ ->
                        Decode.succeed QuoteSent
            )



-- |> jdebug "Status Decoder"


bookingDecoder : Decode.Decoder Booking
bookingDecoder =
    Decode.succeed Booking
        |> Pipeline.required "email" Decode.string
        |> Pipeline.optional "phone" (Decode.nullable Decode.string) Nothing



-- |> jdebug "Booking Decoder"


cleanCarrierName : String -> String
cleanCarrierName name =
    name
        |> String.replace " Application" ""

================
File: src/main.ts
================
import './style.css'
import { Elm } from './Dashboard.elm'
import { db } from './db'
import { applications, bookings, user } from './db/schema'
import { desc, eq, sql } from 'drizzle-orm'

// Define TypeScript types that match Elm's expectations
type Application = {
  id: string
  userId: string
  userEmail: string | null
  createdAt: string
  dateSubmitted: string
  dateCompleted: string
  status: 'quote' | 'review' | 'completed'
  state: string | null
  data: Record<string, any>
  name: string
  booking: {
    email: string
    phone: string | null
  } | null
}

type PaginationRequest = {
  page: number
  pageSize: number
}

const app = Elm.Dashboard.init({
  node: document.getElementById('app')
})

// Helper function to format application data for Elm
const formatApplicationData = async (rawApplications: any[]): Promise<Application[]> => {
  // Get all related bookings for these applications
  const applicationIds = rawApplications.map(app => app.id)
  const relatedBookings = await db
    .select()
    .from(bookings)
    .where(sql`application_id IN ${applicationIds}`)

  // Get all related users
  const userIds = rawApplications.map(app => app.userId)
  const relatedUsers = await db
    .select()
    .from(user)
    .where(sql`id IN ${userIds}`)

  // Create lookup maps
  const bookingsByAppId = new Map(
    relatedBookings.map(booking => [booking.applicationId, booking])
  )
  const usersById = new Map(
    relatedUsers.map(user => [user.id, user])
  )

  return rawApplications.map(app => {
    const relatedBooking = bookingsByAppId.get(app.id)
    const relatedUser = usersById.get(app.userId)

    return {
      id: app.id,
      userId: app.userId,
      userEmail: relatedUser?.email || null,
      createdAt: new Date(app.createdAt).toISOString(),
      dateSubmitted: new Date(app.createdAt).toISOString(),
      dateCompleted: new Date(app.updatedAt).toISOString(),
      status: determineStatus(app.status),
      state: null,
      data: typeof app.data === 'string' ? JSON.parse(app.data) : app.data,
      name: app.name || 'Unknown',
      booking: relatedBooking ? {
        email: relatedBooking.email,
        phone: relatedBooking.phone
      } : null
    }
  })
}

// Helper function to determine status
const determineStatus = (status: string): 'quote' | 'review' | 'completed' => {
  switch (status.toLowerCase()) {
    case 'completed':
      return 'completed'
    case 'review':
      return 'review'
    default:
      return 'quote'
  }
}

// Listen for refresh requests from Elm
app.ports.requestRefresh?.subscribe(async (request: PaginationRequest) => {
  try {
    const { page, pageSize } = request
    const offset = page * pageSize

    // Query applications with pagination
    const rawApplications = await db
      .select({
        id: applications.id,
        userId: applications.userId,
        status: applications.status,
        createdAt: applications.createdAt,
        updatedAt: applications.updatedAt,
        data: applications.data,
        name: applications.name,
      })
      .from(applications)
      .orderBy(desc(applications.createdAt))
      .limit(pageSize)
      .offset(offset)

    // Get total count for pagination info
    const [{ count }] = await db
      .select({ count: sql`count(*)`.mapWith(Number) })
      .from(applications)

    // Format the data for Elm
    const formattedApplications = await formatApplicationData(rawApplications)

    // Send the data back to Elm with pagination info
    app.ports.receiveApplications.send({
      applications: formattedApplications,
      pagination: {
        total: count,
        page,
        pageSize,
        totalPages: Math.ceil(count / pageSize)
      }
    })
  } catch (error) {
    console.error('Error fetching applications:', error)
  }
})

// Handle CSV export requests
app.ports.exportToCsv?.subscribe(async ({ searchTerm, hasContactFilter, hasCSGFilter }) => {
  try {
    let query = db
      .select({
        id: applications.id,
        name: applications.name,
        status: applications.status,
        createdAt: applications.createdAt,
        updatedAt: applications.updatedAt,
        data: applications.data,
      })
      .from(applications)
      .orderBy(desc(applications.createdAt))

    if (searchTerm) {
      query = query.where(sql`name LIKE ${`%${searchTerm}%`}`)
    }

    const results = await query
    const formattedResults = await formatApplicationData(results)
    
    // Convert results to CSV
    const csvContent = convertToCSV(formattedResults)
    downloadCSV(csvContent, 'applications-export.csv')
  } catch (error) {
    console.error('Error exporting to CSV:', error)
  }
})

function convertToCSV(data: Application[]): string {
  const headers = ['ID', 'Name', 'Carrier', 'Status', 'Email', 'Phone', 'Date Submitted', 'Date Completed']
  const rows = data.map(item => {
    const applicantInfo = item.data?.applicant_info || {}
    const fullName = `${applicantInfo.f_name || ''} ${applicantInfo.l_name || ''}`.trim()
    
    return [
      item.id,
      fullName,
      item.name,
      item.status,
      item.booking?.email || item.userEmail || '',
      item.booking?.phone || '',
      new Date(item.dateSubmitted).toLocaleDateString(),
      new Date(item.dateCompleted).toLocaleDateString()
    ]
  })
  
  return [
    headers.join(','),
    ...rows.map(row => row.join(','))
  ].join('\n')
}

function downloadCSV(content: string, filename: string) {
  const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' })
  const link = document.createElement('a')
  link.href = URL.createObjectURL(blob)
  link.download = filename
  link.click()
  URL.revokeObjectURL(link.href)
}

================
File: src/style.css
================
@import "tailwindcss/base";
@import "tailwindcss/components";
@import "tailwindcss/utilities";

================
File: src/typescript.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="32" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path fill="#007ACC" d="M0 128v128h256V0H0z"></path><path fill="#FFF" d="m56.612 128.85l-.081 10.483h33.32v94.68h23.568v-94.68h33.321v-10.28c0-5.69-.122-10.444-.284-10.566c-.122-.162-20.4-.244-44.983-.203l-44.74.122l-.121 10.443Zm149.955-10.742c6.501 1.625 11.459 4.51 16.01 9.224c2.357 2.52 5.851 7.111 6.136 8.208c.08.325-11.053 7.802-17.798 11.988c-.244.162-1.22-.894-2.317-2.52c-3.291-4.795-6.745-6.867-12.028-7.233c-7.76-.528-12.759 3.535-12.718 10.321c0 1.992.284 3.17 1.097 4.795c1.707 3.536 4.876 5.649 14.832 9.956c18.326 7.883 26.168 13.084 31.045 20.48c5.445 8.249 6.664 21.415 2.966 31.208c-4.063 10.646-14.14 17.879-28.323 20.276c-4.388.772-14.79.65-19.504-.203c-10.28-1.828-20.033-6.908-26.047-13.572c-2.357-2.6-6.949-9.387-6.664-9.874c.122-.163 1.178-.813 2.356-1.504c1.138-.65 5.446-3.129 9.509-5.485l7.355-4.267l1.544 2.276c2.154 3.29 6.867 7.801 9.712 9.305c8.167 4.307 19.383 3.698 24.909-1.26c2.357-2.153 3.332-4.388 3.332-7.68c0-2.966-.366-4.266-1.91-6.501c-1.99-2.845-6.054-5.242-17.595-10.24c-13.206-5.69-18.895-9.224-24.096-14.832c-3.007-3.25-5.852-8.452-7.03-12.8c-.975-3.617-1.22-12.678-.447-16.335c2.723-12.76 12.353-21.659 26.25-24.3c4.51-.853 14.994-.528 19.424.569Z"></path></svg>

================
File: src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: drizzle.config.ts
================
import { config } from 'dotenv';
import { defineConfig } from 'drizzle-kit';

config({ path: '.env' });

export default defineConfig({
  schema: './src/db/schema.ts',
  out: './migrations',
  dialect: 'turso',
  dbCredentials: {
    url: process.env.TURSO_DATABASE_URL!,
    authToken: process.env.TURSO_AUTH_TOKEN!,
  },
});

================
File: elm.json
================
{
    "type": "application",
    "source-directories": [
        "src"
    ],
    "elm-version": "0.19.1",
    "dependencies": {
        "direct": {
            "NoRedInk/elm-json-decode-pipeline": "1.0.1",
            "elm/browser": "1.0.2",
            "elm/core": "1.0.5",
            "elm/html": "1.0.0",
            "elm/json": "1.1.3"
        },
        "indirect": {
            "elm/time": "1.0.0",
            "elm/url": "1.0.0",
            "elm/virtual-dom": "1.0.3"
        }
    },
    "test-dependencies": {
        "direct": {},
        "indirect": {}
    }
}

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + TS</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>

================
File: package.json
================
{
  "name": "dash",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "drizzle-kit": "^0.30.1",
    "typescript": "~5.6.2",
    "vite": "^6.0.1",
    "vite-plugin-elm": "^3.0.1"
  },
  "dependencies": {
    "@libsql/client": "0.15.0-pre.1",
    "autoprefixer": "^10.4.20",
    "dotenv": "^16.4.7",
    "drizzle-orm": "^0.38.2",
    "tailwindcss": "^3.4.16"
  }
}

================
File: postcss.config.cjs
================
module.exports = {
    plugins: [
        require("tailwindcss"),
        require("autoprefixer"),
    ],
};

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx,elm}", // This will include all files in src with these extensions
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}

================
File: vite.config.ts
================
import { defineConfig } from 'vite'
import elmPlugin from 'vite-plugin-elm'

export default defineConfig({
  plugins: [elmPlugin()]
})
