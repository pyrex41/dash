This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-12-16T23:48:40.443Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
backend/
  src/
    db/
      index.ts
      query.ts
      schema.ts
    index.ts
  package.json
frontend/
  public/
    vite.svg
  src/
    Dashboard.elm
    main.ts
    style.css
    typescript.svg
    vite-env.d.ts
  elm.json
  index.html
  package.json
  postcss.config.cjs
  tailwind.config.js
  vite.config.ts
.gitignore
drizzle.config.ts
package.json
tree.txt

================================================================
Repository Files
================================================================

================
File: backend/src/db/index.ts
================
import { drizzle } from 'drizzle-orm/libsql';
import { createClient } from '@libsql/client';
import { schema } from './schema';

const dbFile = 'file:./csg.db';
const tursoDbUrl = import.meta.env.VITE_TURSO_DATABASE_URL;
const tursoAuthToken = import.meta.env.VITE_TURSO_AUTH_TOKEN;

const client = createClient({
    url: dbFile, //tursoDbUrl,
    authToken: tursoAuthToken,
    syncUrl: tursoDbUrl,
    syncInterval: 60 // 60 seconds, adjust as needed
});

client.sync();

export const db = drizzle(client, { schema });

================
File: backend/src/db/query.ts
================
import { drizzle } from 'drizzle-orm/libsql'
import { createClient } from '@libsql/client'
import { desc, sql } from 'drizzle-orm'
import { applications, bookings, user, csgApplications } from './schema'

// Database configuration
const client = createClient({
  url: process.env.TURSO_DATABASE_URL!,
  authToken: process.env.TURSO_AUTH_TOKEN!,
})
export const db = drizzle(client)

// Helper function to format application data
export const formatApplicationData = async (rawApplications: any[]) => {
  if (rawApplications.length === 0) return []

  const applicationIds = rawApplications.map(app => app.id)
  const userIds = rawApplications.map(app => app.userId)

  const [relatedBookings, relatedUsers, relatedCsgApps] = await Promise.all([
    db.select().from(bookings).where(sql`application_id IN ${applicationIds}`),
    db.select().from(user).where(sql`id IN ${userIds}`),
    db.select().from(csgApplications).where(sql`application_id IN ${applicationIds}`)
  ])

  const bookingsByAppId = new Map(relatedBookings.map(booking => [booking.applicationId, booking]))
  const usersById = new Map(relatedUsers.map(user => [user.id, user]))
  const csgAppsByAppId = new Map(relatedCsgApps.map(csgApp => [csgApp.applicationId, csgApp]))

  return rawApplications.map(app => {
    const relatedBooking = bookingsByAppId.get(app.id)
    const relatedUser = usersById.get(app.userId)
    const relatedCsgApp = csgAppsByAppId.get(app.id)

    const safeDate = (dateStr: string | number): string => {
      try {
        return new Date(dateStr).toISOString()
      } catch {
        return String(dateStr)
      }
    }

    const status = determineStatus(app.status, !!relatedCsgApp, !!relatedBooking)

    return {
      id: app.id,
      userId: app.userId,
      userEmail: relatedUser?.email || null,
      createdAt: safeDate(app.createdAt),
      dateStarted: safeDate(app.createdAt),
      dateCompleted: null,
      status,
      state: null,
      data: typeof app.data === 'string' ? JSON.parse(app.data) : app.data,
      name: app.name || 'Unknown',
      booking: relatedBooking ? {
        email: relatedBooking.email,
        phone: relatedBooking.phone,
        url: relatedBooking.url,
        status: relatedBooking.status
      } : null,
      csgApplication: relatedCsgApp ? {
        key: relatedCsgApp.key,
        brokerEmail: relatedCsgApp.brokerEmail
      } : null
    }
  })
}

const determineStatus = (
  status: string,
  hasCsgApp: boolean,
  hasBooking: boolean
): 'completed' | 'review' | 'quote' | 'submitted_to_csg' | 'call_booked' => {
  if (hasCsgApp) return 'submitted_to_csg'
  if (hasBooking) return 'call_booked'
  
  switch (status.toLowerCase()) {
    case 'completed': return 'completed'
    case 'review': return 'review'
    default: return 'quote'
  }
}

export const getApplications = async (page: number, pageSize: number, searchTerm: string, hasContactFilter: boolean) => {
  const offset = page * pageSize
  const searchPattern = `%${searchTerm.toLowerCase()}%`
  const shouldSearch = searchTerm.length >= 3

  // Build base query
  let dbQuery = db
    .select({
      id: applications.id,
      userId: applications.userId,
      status: applications.status,
      createdAt: applications.createdAt,
      data: applications.data,
      name: applications.name,
    })
    .from(applications)

  // Add contact filter
  if (hasContactFilter) {
    dbQuery = dbQuery.where(
        sql`(
        json_extract(${applications.data}, '$.applicant_info.email') IS NOT NULL OR
        json_extract(${applications.data}, '$.applicant_info.phone') IS NOT NULL OR
        EXISTS (
            SELECT 1 FROM ${bookings}
            WHERE ${bookings.applicationId} = ${applications.id}
            AND (${bookings.email} IS NOT NULL OR ${bookings.phone} IS NOT NULL)
        ) OR
        EXISTS (
            SELECT 1 FROM ${user}
            WHERE ${user.id} = ${applications.userId}
            AND ${user.email} IS NOT NULL
        )
        )`
    )
    }

  // Add search conditions
  if (shouldSearch) {
    dbQuery = dbQuery.where(
      sql`(
        LOWER(json_extract(${applications.data}, '$.applicant_info.f_name')) LIKE ${searchPattern} OR
        LOWER(json_extract(${applications.data}, '$.applicant_info.l_name')) LIKE ${searchPattern} OR
        LOWER(json_extract(${applications.data}, '$.applicant_info.phone')) LIKE ${searchPattern} OR
        LOWER(json_extract(${applications.data}, '$.applicant_info.email')) LIKE ${searchPattern} OR
        LOWER(${applications.name}) LIKE ${searchPattern} OR
        EXISTS (
            SELECT 1 FROM ${bookings}
            WHERE ${bookings.applicationId} = ${applications.id}
            AND (
            LOWER(${bookings.email}) LIKE ${searchPattern}
            ${bookings.phone ? sql`OR LOWER(${bookings.phone}) LIKE ${searchPattern}` : sql``}
            )
        ) OR
        EXISTS (
            SELECT 1 FROM ${user}
            WHERE ${user.id} = ${applications.userId}
            AND LOWER(${user.email}) LIKE ${searchPattern}
        
        )`
    )
  }

  // Execute queries
  const [results, totalCount] = await Promise.all([
    dbQuery
      .orderBy(desc(applications.createdAt))
      .limit(pageSize)
      .offset(offset),
    db
      .select({ count: sql`count(*)`.mapWith(Number) })
      .from(applications)
      .where(shouldSearch || hasContactFilter
              ? sql`${
                  hasContactFilter
                    ? sql`(
                        json_extract(${applications.data}, '$.applicant_info.email') IS NOT NULL OR
                        json_extract(${applications.data}, '$.applicant_info.phone') IS NOT NULL OR
                        EXISTS (
                          SELECT 1 FROM ${bookings}
                          WHERE ${bookings.applicationId} = ${applications.id}
                          AND (${bookings.email} IS NOT NULL OR ${bookings.phone} IS NOT NULL)
                        ) OR
                        EXISTS (
                          SELECT 1 FROM ${user}
                          WHERE ${user.id} = ${applications.userId}
                          AND ${user.email} IS NOT NULL
                        )
                      )`
                    : sql`1=1`
                } AND ${
                  shouldSearch
                    ? sql`(
                        LOWER(json_extract(${applications.data}, '$.applicant_info.f_name')) LIKE ${searchPattern} OR
                        LOWER(json_extract(${applications.data}, '$.applicant_info.l_name')) LIKE ${searchPattern} OR
                        LOWER(json_extract(${applications.data}, '$.applicant_info.phone')) LIKE ${searchPattern} OR
                        LOWER(json_extract(${applications.data}, '$.applicant_info.email')) LIKE ${searchPattern} OR
                        LOWER(${applications.name}) LIKE ${searchPattern} OR
                        EXISTS (
                          SELECT 1 FROM ${bookings}
                          WHERE ${bookings.applicationId} = ${applications.id}
                          AND (
                            LOWER(${bookings.email}) LIKE ${searchPattern}
                            ${bookings.phone ? sql`OR LOWER(${bookings.phone}) LIKE ${searchPattern}` : sql``}
                          )
                        ) OR
                        EXISTS (
                          SELECT 1 FROM ${user}
                          WHERE ${user.id} = ${applications.userId}
                          AND LOWER(${user.email}) LIKE ${searchPattern}
                        )
                      )`
                    : sql`1=1`
                }`
              : undefined
            )
  ])

  const formattedApplications = await formatApplicationData(results)

  return {
    applications: formattedApplications,
    pagination: {
      total: totalCount[0].count,
      page,
      pageSize,
      totalPages: Math.ceil(totalCount[0].count / pageSize)
    }
  }
}

export const exportApplications = async (searchTerm: string, hasContactFilter: boolean) => {
  let dbQuery = db
    .select({
      id: applications.id,
      name: applications.name,
      status: applications.status,
      createdAt: applications.createdAt,
      updatedAt: applications.updatedAt,
      data: applications.data,
    })
    .from(applications)
    .orderBy(desc(applications.createdAt))

  if (searchTerm.length >= 3) {
    dbQuery = dbQuery.where(sql`name LIKE ${`%${searchTerm}%`}`)
  }

  const results = await dbQuery
  return formatApplicationData(results)
}

================
File: backend/src/db/schema.ts
================
// /server/db/schema.ts
import { sql } from 'drizzle-orm';
import { sqliteTable, text, integer, unique, index } from 'drizzle-orm/sqlite-core';

export const user = sqliteTable('user', {
  id: text('id').primaryKey().notNull(),
  createdAt: integer('createdAt', { mode: 'timestamp' })
    .default(sql`(CURRENT_TIMESTAMP)`)
    .notNull(),
  updatedAt: integer('updatedAt', { mode: 'timestamp' })
    .default(sql`(CURRENT_TIMESTAMP)`)
    .notNull(),
  email: text('email'),
  isTemporary: integer('is_temporary', { mode: 'boolean' }).notNull().default(true),
  isAnonymous: integer('is_anonymous', { mode: 'boolean' }).notNull().default(true),
});

export const applications = sqliteTable(
  'applications',
  {
    id: text('id').primaryKey().notNull(),
    userId: text('user_id')
      .notNull()
      .references(() => user.id),
    status: text('status').notNull(),
    createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
    updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull(),
    data: text('data', { mode: 'json' }).$type<Record<string, any>>().notNull(),
    name: text('name'),
    naic: text('naic'),
    zip: text('zip').notNull(),
    county: text('county').notNull(),
    dob: text('dob').notNull(),
    schema: text('schema', { mode: 'json' }).$type<Record<string, any>>().notNull(),
    originalSchema: text('original_schema', { mode: 'json' }).$type<Record<string, any>>().notNull(),
    underwritingType: integer('underwriting_type').notNull().default(0),
  },
  (table) => ({
    csgKeyIndex: index('idx_applications_csg_key').on(table.id),
    underwritingTypeCheck: sql`CHECK (underwriting_type IN (0, 1, 2))`
  })
);

export const csgApplications = sqliteTable(
  'csg_applications',
  {
    id: integer('id').primaryKey({ autoIncrement: true }),
    applicationId: text('application_id')
      .notNull()
      .references(() => applications.id),
    key: text('key').notNull(),
    responseBody: text('response_body').notNull(),
    brokerEmail: text('broker_email'),
    createdAt: integer('created_at', { mode: 'timestamp' })
      .notNull()
      .default(sql`CURRENT_TIMESTAMP`),
    updatedAt: integer('updated_at', { mode: 'timestamp' })
      .notNull()
      .default(sql`CURRENT_TIMESTAMP`),
  },
  (table) => ({
    applicationIdIndex: index('idx_csg_applications_application_id').on(table.applicationId),
    keyIndex: index('idx_csg_applications_key').on(table.key),
  })
);

export const onboarding = sqliteTable('onboarding', {
  id: text('id').primaryKey(),
  userId: text('user_id')
    .notNull()
    .references(() => user.id),
  createdAt: integer('created_at', { mode: 'timestamp' })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
  updatedAt: integer('updated_at', { mode: 'timestamp' })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
  data: text('data', { mode: 'json' }).notNull(),
});

export const csgTokens = sqliteTable('csg_tokens', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  token: text('token').notNull(),
  expiresAt: integer('expires_at', { mode: 'timestamp' }).notNull(),
  createdAt: integer('created_at', { mode: 'timestamp' })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
  updatedAt: integer('updated_at', { mode: 'timestamp' })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
}, (table) => ({
  tokenIndex: index('idx_csg_tokens_token').on(table.token),
  expiresAtIndex: index('idx_csg_tokens_expires_at').on(table.expiresAt),
}));

export const brokers = sqliteTable('brokers', {
  id: text('id').primaryKey(),
  username: text('username').notNull().unique(),
  passwordHash: text('password_hash').notNull(),
  createdAt: integer('created_at', { mode: 'timestamp' })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
  updatedAt: integer('updated_at', { mode: 'timestamp' })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
});

export const bookings = sqliteTable('bookings', {
  id: text('id').primaryKey().notNull(),
  userId: text('user_id')
    .references(() => user.id),
  applicationId: text('application_id')
    .references(() => applications.id),
  email: text('email').notNull(),
  phone: text('phone'),
  url: text('url').notNull(),
  event: text('event'),
  status: text('status').notNull(),
  createdAt: text('created_at')
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
  updatedAt: text('updated_at')
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
}, (table) => ({
  userIdIndex: index('idx_bookings_user_id').on(table.userId),
  emailIndex: index('idx_bookings_email').on(table.email),
  applicationIdIndex: index('idx_bookings_application_id').on(table.applicationId),
}));

export const schema = {
  user,
  applications,
  csgApplications,
  onboarding,
  csgTokens,
  brokers,
  bookings
};

================
File: backend/src/index.ts
================
import { Elysia } from 'elysia'
import { cors } from '@elysiajs/cors'
import { join, dirname } from 'path'
import { fileURLToPath } from 'url'
import staticPlugin from '@elysiajs/static'
import { getApplications, exportApplications } from './db/query'

// Resolve __dirname for ESM environments
const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

// Detect environment
const isDev = process.env.NODE_ENV === 'development' || !process.env.NODE_ENV

const app = new Elysia().use(cors())

// --------------------------
// API Routes
// --------------------------
app.group('/api', app => app
  .get('/applications', async ({ query: params }) => {
    try {
      const page = Number(params?.page) || 0
      const pageSize = Number(params?.pageSize) || 20
      const searchTerm = params?.searchTerm as string || ''
      const hasContactFilter = params?.hasContactFilter === 'true'
      
      return await getApplications(page, pageSize, searchTerm, hasContactFilter)
    } catch (error) {
      console.error('Error fetching applications:', error)
      return {
        applications: [],
        pagination: {
          total: 0,
          page: 0,
          pageSize: 20,
          totalPages: 0
        }
      }
    }
  })
  .get('/applications/export', async ({ query: params }) => {
    try {
      const searchTerm = params?.searchTerm as string || ''
      const hasContactFilter = params?.hasContactFilter === 'true'
      
      return await exportApplications(searchTerm, hasContactFilter)
    } catch (error) {
      console.error('Error exporting applications:', error)
      return []
    }
  })
)

// --------------------------
// Production static handling
// --------------------------
if (!isDev) {
  try {
    const distPath = join(__dirname, '../../dist')

    const mimeTypes: Record<string, string> = {
      '.js': 'application/javascript',
      '.mjs': 'application/javascript',
      '.css': 'text/css',
      '.html': 'text/html',
      '.json': 'application/json',
      '.png': 'image/png',
      '.jpg': 'image/jpeg',
      '.jpeg': 'image/jpeg',
      '.gif': 'image/gif',
      '.svg': 'image/svg+xml',
      '.ico': 'image/x-icon',
      '.woff': 'font/woff',
      '.woff2': 'font/woff2',
      '.ttf': 'font/ttf',
      '.eot': 'application/vnd.ms-fontobject',
    }

    // Serve static files from the dist directory
    app.use(staticPlugin({
      assets: distPath,
      prefix: '/',
      alwaysStatic: true,
      headers: (path) => {
        const ext = '.' + path.split('.').pop()
        const mime = mimeTypes[ext] || 'application/octet-stream'
        return {
          'Content-Type': mime,
          'Cache-Control': 'public, max-age=31536000',
          'X-Content-Type-Options': 'nosniff',
        }
      }
    }))

    // Fallback route: serve index.html for non-asset requests
    app.get('*', async ({ request }) => {
      const { pathname } = new URL(request.url)

      // If the request has a file extension and wasn't served by staticPlugin, return 404
      if (/\.[^/]+$/.test(pathname)) {
        return new Response('Not found', { status: 404 })
      }

      // Otherwise, serve the SPA's index.html
      try {
        const htmlPath = join(distPath, 'index.html')
        const html = await Bun.file(htmlPath).text()
        return new Response(html, {
          headers: {
            'Content-Type': 'text/html',
            'Cache-Control': 'no-cache'
          }
        })
      } catch (error) {
        console.error('Error serving index.html:', error)
        return new Response('Server Error', { status: 500 })
      }
    })
  } catch (error) {
    console.error('Error setting up static file handling:', error)
  }
}

app.listen(process.env.PORT || 3000)

console.log(
  `🦊 Elysia is running at ${app.server?.hostname}:${app.server?.port} (${isDev ? 'development' : 'production'} mode)`
)

================
File: backend/package.json
================
{
    "name": "dashboard-backend",
    "module": "src/index.ts",
    "type": "module",
    "scripts": {
        "dev": "NODE_ENV=development bun run --watch src/index.ts",
        "start": "NODE_ENV=production bun run src/index.ts"
    },
    "dependencies": {
        "@elysiajs/cors": "^1.1.1",
        "@elysiajs/static": "^1.1.1",
        "@libsql/client": "^0.14.0",
        "drizzle-orm": "^0.38.2",
        "elysia": "^1.1.26"
    },
    "devDependencies": {
        "bun-types": "latest"
    }
}

================
File: frontend/public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: frontend/src/Dashboard.elm
================
port module Dashboard exposing (Model, Msg, init, update, view)

import Browser
import Debounce exposing (Debounce)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Json.Decode as Decode
import Json.Decode.Pipeline as Pipeline



-- PORTS


type alias PaginationInfo =
    { total : Int
    , page : Int
    , pageSize : Int
    , totalPages : Int
    }


type alias ApplicationsResponse =
    { applications : List Application
    , pagination : PaginationInfo
    }


port receiveApplications : (Decode.Value -> msg) -> Sub msg


port requestRefresh : { page : Int, pageSize : Int, searchTerm : String, hasContactFilter : Bool } -> Cmd msg


port exportToCsv : { searchTerm : String, hasContactFilter : Bool, hasCSGFilter : Bool } -> Cmd msg



-- MAIN


main =
    Browser.element
        { init = init
        , update = update
        , subscriptions = subscriptions
        , view = view
        }



-- MODEL


type alias Model =
    { quoteSent : Int
    , submissions : Int
    , waitingReview : Int
    , completedApps : Int
    , applications : List Application
    , searchTerm : String
    , hasContactFilter : Bool
    , hasCSGFilter : Bool
    , isLoading : Bool
    , error : Maybe String
    , searchDebouncer : Debounce String
    , searchLoading : Bool
    , currentPage : Int
    , pageSize : Int
    , total : Int
    , totalPages : Int
    }


type alias Application =
    { id : String
    , userId : String
    , userEmail : Maybe String
    , createdAt : String
    , dateStarted : String
    , status : Status
    , state : Maybe String
    , data : Decode.Value
    , carrier : String
    , booking : Maybe Booking
    , csgApplication : Maybe CsgApplication
    }


type alias CsgApplication =
    { key : String
    , brokerEmail : Maybe String
    }


type alias Booking =
    { email : String
    , phone : Maybe String
    , url : String
    , status : String
    }


type Status
    = CompletedApp
    | WaitingReview
    | QuoteSent
    | SubmittedToCSG
    | CallBooked



-- INIT


init : () -> ( Model, Cmd Msg )
init _ =
    ( { quoteSent = 0
      , submissions = 0
      , waitingReview = 0
      , completedApps = 0
      , applications = []
      , searchTerm = ""
      , hasContactFilter = False
      , hasCSGFilter = False
      , isLoading = True
      , error = Nothing
      , searchDebouncer = Debounce.init
      , searchLoading = False
      , currentPage = 0
      , pageSize = 20
      , total = 0
      , totalPages = 0
      }
    , requestRefresh
        { page = 0
        , pageSize = 20
        , searchTerm = ""
        , hasContactFilter = False
        }
    )



-- UPDATE


type Msg
    = NoOp
    | ViewApplication String
    | CompleteApplication String
    | SearchTermChanged String
    | ToggleContactFilter Bool
    | ToggleCSGFilter Bool
    | RefreshApplications
    | ApplicationsReceived (Result Decode.Error ApplicationsResponse)
    | ExportToCsv
    | SearchDebouncerMsg Debounce.Msg
    | PerformSearch String
    | ChangePage Int


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        NoOp ->
            ( model, Cmd.none )

        ViewApplication id ->
            ( model, Cmd.none )

        CompleteApplication id ->
            ( model, Cmd.none )

        SearchTermChanged term ->
            let
                trimmedTerm =
                    String.trim term

                shouldSearch =
                    String.length trimmedTerm >= 3

                shouldRefresh =
                    String.length trimmedTerm == 0 && String.length (String.trim model.searchTerm) > 0

                ( debouncer, cmd ) =
                    if shouldSearch then
                        Debounce.push searchDebounceConfig trimmedTerm model.searchDebouncer

                    else if shouldRefresh then
                        ( model.searchDebouncer
                        , requestRefresh
                            { page = 0
                            , pageSize = 20
                            , searchTerm = ""
                            , hasContactFilter = False
                            }
                        )

                    else
                        ( model.searchDebouncer, Cmd.none )
            in
            ( { model
                | searchTerm = term
                , searchDebouncer = debouncer
                , searchLoading = shouldSearch
                , isLoading = shouldRefresh
              }
            , cmd
            )

        SearchDebouncerMsg debouncerMsg ->
            let
                ( debouncer, cmd ) =
                    Debounce.update
                        searchDebounceConfig
                        (Debounce.takeLast performSearch)
                        debouncerMsg
                        model.searchDebouncer
            in
            ( { model | searchDebouncer = debouncer }
            , cmd
            )

        ToggleContactFilter value ->
            ( { model | hasContactFilter = value, isLoading = True }
            , requestRefresh
                { page = model.currentPage
                , pageSize = model.pageSize
                , searchTerm = model.searchTerm
                , hasContactFilter = value
                }
            )

        ToggleCSGFilter value ->
            ( { model | hasCSGFilter = value }, Cmd.none )

        RefreshApplications ->
            ( { model | isLoading = True }, requestRefresh { page = 0, pageSize = 20, searchTerm = "", hasContactFilter = False } )

        ApplicationsReceived (Ok response) ->
            ( { model
                | applications = response.applications
                , isLoading = False
                , searchLoading = False
                , quoteSent = List.length (List.filter (\a -> a.status == QuoteSent) response.applications)
                , submissions = List.length (List.filter (\a -> a.status == QuoteSent) response.applications)
                , waitingReview = List.length (List.filter (\a -> a.status == WaitingReview) response.applications)
                , completedApps = List.length (List.filter (\a -> a.status == CompletedApp) response.applications)
                , total = response.pagination.total
                , totalPages = response.pagination.totalPages
                , currentPage = response.pagination.page
                , pageSize = response.pagination.pageSize
              }
            , Cmd.none
            )

        ApplicationsReceived (Err _) ->
            ( { model | error = Just "Failed to load applications", isLoading = False, searchLoading = False }, Cmd.none )

        ExportToCsv ->
            ( model
            , exportToCsv
                { searchTerm = model.searchTerm
                , hasContactFilter = model.hasContactFilter
                , hasCSGFilter = model.hasCSGFilter
                }
            )

        PerformSearch term ->
            ( model
            , requestRefresh
                { page = 0
                , pageSize = 20
                , searchTerm = term
                , hasContactFilter = False
                }
            )

        ChangePage page ->
            ( { model | currentPage = page, isLoading = True }
            , requestRefresh
                { page = page
                , pageSize = model.pageSize
                , searchTerm = model.searchTerm
                , hasContactFilter = False
                }
            )



-- Add completion logic here
-- VIEW


view : Model -> Html Msg
view model =
    div [ class "min-h-screen bg-white" ]
        [ viewHeader
        , div [ class "max-w-7xl mx-auto" ]
            [ viewMetrics model
            , viewApplications model
            ]
        ]


viewHeader : Html Msg
viewHeader =
    header [ class "border-b" ]
        [ div [ class "max-w-7xl mx-auto flex justify-between items-center p-4" ]
            [ div [ class "flex items-center gap-4" ]
                [ h1 [ class "text-xl font-bold" ] [ text "White Labeled Logo" ]
                , nav [ class "flex gap-4" ]
                    [ a [ href "#" ] [ text "Medigap Applications" ]
                    , a [ href "#" ] [ text "Contacts" ]
                    ]
                ]
            , div [ class "flex items-center gap-4" ]
                [ button [ class "bg-black text-white px-4 py-2 rounded" ]
                    [ text "Send Something" ]
                , div [ class "flex items-center gap-2" ]
                    [ span [ class "w-8 h-8 bg-gray-200 rounded-full flex items-center justify-center" ]
                        [ text "J" ]
                    , text "John Doe"
                    ]
                ]
            ]
        ]


viewMetrics : Model -> Html Msg
viewMetrics model =
    div [ class "grid grid-cols-4 gap-4 p-4" ]
        [ viewMetricCard "Quote Sent" model.quoteSent "80" "up"
        , viewMetricCard "Submissions" model.submissions "20" "up"
        , viewMetricCard "Waiting Review" model.waitingReview "10" "down"
        , viewMetricCard "Completed Apps" model.completedApps "" ""
        ]


viewMetricCard : String -> Int -> String -> String -> Html Msg
viewMetricCard title value percentage direction =
    div [ class "p-4 rounded-lg border" ]
        [ div [ class "text-sm text-gray-600" ] [ text title ]
        , div [ class "text-3xl font-bold" ] [ text (String.fromInt value) ]
        , if percentage /= "" then
            div
                [ class
                    ("text-sm "
                        ++ (if direction == "up" then
                                "text-green-500"

                            else
                                "text-red-500"
                           )
                    )
                ]
                [ text (percentage ++ "% vs last month") ]

          else
            text ""
        ]


viewApplications : Model -> Html Msg
viewApplications model =
    div [ class "p-4" ]
        [ div [ class "flex justify-between items-center mb-4" ]
            [ h2 [ class "text-xl" ] [ text "Applications" ]
            , div [ class "flex gap-4 items-center" ]
                [ label [ class "flex items-center gap-2 text-sm text-gray-600" ]
                    [ input
                        [ type_ "checkbox"
                        , class "rounded border-gray-300"
                        , checked model.hasContactFilter
                        , onCheck ToggleContactFilter
                        ]
                        []
                    , text "Has contact info"
                    ]
                , div [ class "relative" ]
                    [ input
                        [ class "px-3 py-1 border rounded"
                        , placeholder "Search"
                        , type_ "search"
                        , value model.searchTerm
                        , onInput SearchTermChanged
                        ]
                        []
                    , if model.searchLoading && String.length model.searchTerm >= 3 then
                        div
                            [ class "absolute right-2 top-1/2 transform -translate-y-1/2" ]
                            [ div
                                [ class "animate-spin h-4 w-4 border-2 border-gray-300 border-t-purple-600 rounded-full" ]
                                []
                            ]

                      else
                        text ""
                    ]
                ]
            ]
        , if model.isLoading then
            div [ class "flex justify-center items-center py-8" ]
                [ div [ class "animate-spin rounded-full h-12 w-12 border-b-2 border-purple-600" ] []
                , span [ class "sr-only" ] [ text "Loading..." ]
                ]

          else
            div []
                [ table [ class "w-full border-collapse" ]
                    [ thead []
                        [ tr [ class "border-b text-left" ]
                            [ th [ class "w-8 py-3 px-4" ]
                                [ input [ type_ "checkbox", class "rounded border-gray-300" ] [] ]
                            , th [ class "py-3 px-4 font-medium text-sm text-gray-600 w-48" ] [ text "Name" ]
                            , th [ class "py-3 px-4 font-medium text-sm text-gray-600 w-32" ] [ text "Carrier" ]
                            , th [ class "py-3 px-4 font-medium text-sm text-gray-600 w-32" ] [ text "Status" ]
                            , th [ class "py-3 px-4 font-medium text-sm text-gray-600 w-36" ] [ text "Phone Number" ]
                            , th [ class "py-3 px-4 font-medium text-sm text-gray-600 w-48" ] [ text "Email address" ]
                            , th [ class "py-3 px-4 font-medium text-sm text-gray-600 w-28" ] [ text "Effective Date" ]
                            , th [ class "py-3 px-4 font-medium text-sm text-gray-600 w-28" ] [ text "Date Started" ]
                            , th [ class "py-3 px-4 font-medium text-sm text-gray-600 w-24" ] [ text "" ]
                            ]
                        ]
                    , tbody []
                        (List.map viewApplicationRow model.applications)
                    ]
                , viewPagination model
                ]
        ]


viewApplicationRow : Application -> Html Msg
viewApplicationRow app =
    let
        getName =
            let
                firstName =
                    app.data
                        |> Decode.decodeValue (Decode.at [ "applicant_info", "f_name" ] Decode.string)
                        |> Result.toMaybe
                        |> Maybe.withDefault ""

                lastName =
                    app.data
                        |> Decode.decodeValue (Decode.at [ "applicant_info", "l_name" ] Decode.string)
                        |> Result.toMaybe
                        |> Maybe.withDefault ""
            in
            String.trim (firstName ++ " " ++ lastName)

        getApplicantInfo field =
            app.data
                |> Decode.decodeValue (Decode.at [ "applicant_info", field ] Decode.string)
                |> Result.toMaybe

        getEmail =
            [ app.userEmail -- From user
            , getApplicantInfo "email" -- From application data
            , Maybe.map .email app.booking -- From booking
            ]
                |> List.filterMap identity
                |> List.head
                |> Maybe.withDefault ""

        getPhone =
            [ getApplicantInfo "phone" -- From application data
            , Maybe.andThen .phone app.booking -- From booking
            ]
                |> List.filterMap identity
                |> List.head
                |> Maybe.withDefault ""

        getEffectiveDate =
            app.data
                |> Decode.decodeValue (Decode.at [ "applicant_info", "effective_date" ] Decode.string)
                |> Result.toMaybe

        formatDate dateString =
            dateString
                |> String.split "T"
                |> List.head
                |> Maybe.withDefault dateString
    in
    tr [ class "border-b hover:bg-gray-50" ]
        [ td [ class "py-3 px-4 w-8" ]
            [ input [ type_ "checkbox", class "rounded border-gray-300" ] [] ]
        , td [ class "py-3 px-4 w-48" ] [ text getName ]
        , td [ class "py-3 px-4 w-32" ] [ text app.carrier ]
        , td [ class "py-3 px-4 w-32" ] [ viewStatus app.status ]
        , td [ class "py-3 px-4 text-gray-600 w-36 whitespace-nowrap" ] [ text getPhone ]
        , td [ class "py-3 px-4 text-gray-600 w-48 truncate" ] [ text getEmail ]
        , td [ class "py-3 px-4 text-gray-600 w-28 whitespace-nowrap" ]
            [ text (getEffectiveDate |> Maybe.map formatDate |> Maybe.withDefault "") ]
        , td [ class "py-3 px-4 text-gray-600 w-28 whitespace-nowrap" ] [ text (formatDate app.dateStarted) ]
        , td [ class "py-3 px-4 w-24" ]
            [ button
                [ class "bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-md text-sm"
                , onClick (ViewApplication app.id)
                ]
                [ text "View" ]
            ]
        ]


viewStatus : Status -> Html Msg
viewStatus status =
    let
        ( statusText, statusColor ) =
            case status of
                CompletedApp ->
                    ( "Completed App", "text-green-600 bg-green-50" )

                WaitingReview ->
                    ( "Waiting Review", "text-red-600 bg-red-50" )

                QuoteSent ->
                    ( "Started", "text-blue-600 bg-blue-50" )

                SubmittedToCSG ->
                    ( "Submitted to CSG", "text-purple-600 bg-purple-50" )

                CallBooked ->
                    ( "Intro Call", "text-orange-600 bg-orange-50" )
    in
    div [ class ("flex items-center gap-2 " ++ statusColor ++ " px-3 py-1 rounded-full w-fit") ]
        [ div [ class "w-2 h-2 rounded-full bg-current" ] []
        , span [ class "text-sm" ] [ text statusText ]
        ]



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions _ =
    receiveApplications
        (Decode.decodeValue applicationListDecoder >> ApplicationsReceived)



-- DECODERS
{--
jdebug : String -> Decode.Decoder a -> Decode.Decoder a
jdebug message decoder =
    Decode.value
        |> Decode.andThen (debugHelper message decoder)


debugHelper : String -> Decode.Decoder a -> Decode.Value -> Decode.Decoder a
debugHelper message decoder value =
    let
        _ =
            Debug.log message (Decode.decodeValue decoder value)
    in
    decoder
--}


applicationDecoder : Decode.Decoder Application
applicationDecoder =
    Decode.succeed Application
        |> Pipeline.required "id" Decode.string
        |> Pipeline.required "userId" Decode.string
        |> Pipeline.optional "userEmail" (Decode.nullable Decode.string) Nothing
        |> Pipeline.required "createdAt" Decode.string
        |> Pipeline.required "dateStarted" Decode.string
        |> Pipeline.required "status" statusDecoder
        |> Pipeline.optional "state" (Decode.nullable Decode.string) Nothing
        |> Pipeline.required "data" Decode.value
        |> Pipeline.required "name" (Decode.map cleanCarrierName Decode.string)
        |> Pipeline.optional "booking" (Decode.nullable bookingDecoder) Nothing
        |> Pipeline.optional "csgApplication" (Decode.nullable csgApplicationDecoder) Nothing



-- |> jdebug "Application Decoder"


applicationListDecoder : Decode.Decoder ApplicationsResponse
applicationListDecoder =
    Decode.map2 ApplicationsResponse
        (Decode.field "applications" (Decode.list applicationDecoder))
        (Decode.field "pagination" paginationDecoder)



-- |> jdebug "Application List Decoder"


paginationDecoder : Decode.Decoder PaginationInfo
paginationDecoder =
    Decode.map4 PaginationInfo
        (Decode.field "total" Decode.int)
        (Decode.field "page" Decode.int)
        (Decode.field "pageSize" Decode.int)
        (Decode.field "totalPages" Decode.int)



-- |> jdebug "Pagination Decoder"


statusDecoder : Decode.Decoder Status
statusDecoder =
    Decode.string
        |> Decode.andThen
            (\str ->
                case str of
                    "completed" ->
                        Decode.succeed CompletedApp

                    "review" ->
                        Decode.succeed WaitingReview

                    "quote" ->
                        Decode.succeed QuoteSent

                    "submitted_to_csg" ->
                        Decode.succeed SubmittedToCSG

                    "call_booked" ->
                        Decode.succeed CallBooked

                    _ ->
                        Decode.succeed QuoteSent
            )



-- |> jdebug "Status Decoder"


bookingDecoder : Decode.Decoder Booking
bookingDecoder =
    Decode.succeed Booking
        |> Pipeline.required "email" Decode.string
        |> Pipeline.optional "phone" (Decode.nullable Decode.string) Nothing
        |> Pipeline.required "url" Decode.string
        |> Pipeline.required "status" Decode.string



-- |> jdebug "Booking Decoder"


csgApplicationDecoder : Decode.Decoder CsgApplication
csgApplicationDecoder =
    Decode.succeed CsgApplication
        |> Pipeline.required "key" Decode.string
        |> Pipeline.optional "brokerEmail" (Decode.nullable Decode.string) Nothing



-- |> jdebug "CSG Application Decoder"


cleanCarrierName : String -> String
cleanCarrierName name =
    name
        |> String.replace " Application" ""



-- Debounce config


searchDebounceConfig : Debounce.Config Msg
searchDebounceConfig =
    { strategy = Debounce.later 300
    , transform = SearchDebouncerMsg
    }



-- Helper function to perform the actual search


performSearch : String -> Cmd Msg
performSearch term =
    requestRefresh
        { page = 0
        , pageSize = 20
        , searchTerm = term
        , hasContactFilter = False
        }


viewPagination : Model -> Html Msg
viewPagination model =
    div [ class "mt-4 flex items-center justify-between border-t border-gray-200 px-4 py-3 sm:px-6" ]
        [ div [ class "flex flex-1 justify-between sm:hidden" ]
            [ button
                [ class "relative inline-flex items-center rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
                , onClick (ChangePage (model.currentPage - 1))
                , disabled (model.currentPage <= 0)
                ]
                [ text "Previous" ]
            , button
                [ class "relative ml-3 inline-flex items-center rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
                , onClick (ChangePage (model.currentPage + 1))
                , disabled (model.currentPage >= model.totalPages - 1)
                ]
                [ text "Next" ]
            ]
        , div [ class "hidden sm:flex sm:flex-1 sm:items-center sm:justify-between" ]
            [ div [ class "text-sm text-gray-700" ]
                [ span [] [ text "Showing " ]
                , span [ class "font-medium" ]
                    [ text (String.fromInt (model.currentPage * model.pageSize + 1))
                    , text " to "
                    , text (String.fromInt (Basics.min ((model.currentPage + 1) * model.pageSize) model.total))
                    ]
                , span [] [ text " of " ]
                , span [ class "font-medium" ] [ text (String.fromInt model.total) ]
                , span [] [ text " results" ]
                ]
            , div [ class "flex items-center gap-2" ]
                [ viewPageButtons model ]
            ]
        ]


viewPageButtons : Model -> Html Msg
viewPageButtons model =
    let
        pageNumbers =
            List.range 0 (model.totalPages - 1)
                |> List.filter
                    (\page ->
                        page
                            == 0
                            || page
                            == model.totalPages
                            - 1
                            || abs (page - model.currentPage)
                            <= 1
                    )
                |> List.sort
    in
    div [ class "flex gap-1" ]
        (List.map (viewPageButton model.currentPage) pageNumbers)


viewPageButton : Int -> Int -> Html Msg
viewPageButton currentPage page =
    button
        [ class
            (if page == currentPage then
                "relative inline-flex items-center px-4 py-2 text-sm font-semibold text-white bg-purple-600 focus:z-20 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-purple-600"

             else
                "relative inline-flex items-center px-4 py-2 text-sm font-semibold text-gray-900 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0"
            )
        , onClick (ChangePage page)
        ]
        [ text (String.fromInt (page + 1)) ]

================
File: frontend/src/main.ts
================
// Log to confirm script loading
console.log('Main script loading...');

import './style.css';
import { Elm } from './Dashboard.elm';

console.log('Imports completed');

document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM loaded, initializing Elm...');
    const target = document.getElementById('app');
    
    if (!target) {
        console.error('Target element #app not found!');
        return;
    }

    try {
        const app = Elm.Dashboard.init({
            node: target
        });

        console.log('Elm app initialized');

        // Port handlers for interacting with Elm
        app.ports.requestRefresh?.subscribe(({ page, pageSize, searchTerm, hasContactFilter }) => {
            console.log('Refresh requested:', { page, pageSize, searchTerm, hasContactFilter });
            fetch(`/api/applications?page=${page}&pageSize=${pageSize}&searchTerm=${searchTerm}&hasContactFilter=${hasContactFilter}`)
                .then(response => response.json())
                .then(data => {
                    console.log('Data received:', data);
                    app.ports.receiveApplications.send(data);
                })
                .catch(error => {
                    console.error('Error fetching applications:', error);
                    app.ports.receiveApplications.send({
                        applications: [],
                        pagination: {
                            total: 0,
                            page: 0,
                            pageSize: 20,
                            totalPages: 0
                        }
                    });
                });
        });

        app.ports.exportToCsv?.subscribe(({ searchTerm, hasContactFilter, hasCSGFilter }) => {
            window.location.href = `/api/applications/export?searchTerm=${searchTerm}&hasContactFilter=${hasContactFilter}&hasCSGFilter=${hasCSGFilter}`;
        });
    } catch (error) {
        console.error('Error initializing Elm app:', error);
    }
});

================
File: frontend/src/style.css
================
@import "tailwindcss/base";
@import "tailwindcss/components";
@import "tailwindcss/utilities";

================
File: frontend/src/typescript.svg
================
<svg
  xmlns="http://www.w3.org/2000/svg"
  xmlns:xlink="http://www.w3.org/1999/xlink"
  aria-hidden="true"
  role="img"
  class="iconify iconify--logos"
  width="32"
  height="32"
  preserveAspectRatio="xMidYMid meet"
  viewBox="0 0 256 256"
><path fill="#007ACC" d="M0 128v128h256V0H0z" /><path
    fill="#FFF"
    d="m56.612 128.85l-.081 10.483h33.32v94.68h23.568v-94.68h33.321v-10.28c0-5.69-.122-10.444-.284-10.566c-.122-.162-20.4-.244-44.983-.203l-44.74.122l-.121 10.443Zm149.955-10.742c6.501 1.625 11.459 4.51 16.01 9.224c2.357 2.52 5.851 7.111 6.136 8.208c.08.325-11.053 7.802-17.798 11.988c-.244.162-1.22-.894-2.317-2.52c-3.291-4.795-6.745-6.867-12.028-7.233c-7.76-.528-12.759 3.535-12.718 10.321c0 1.992.284 3.17 1.097 4.795c1.707 3.536 4.876 5.649 14.832 9.956c18.326 7.883 26.168 13.084 31.045 20.48c5.445 8.249 6.664 21.415 2.966 31.208c-4.063 10.646-14.14 17.879-28.323 20.276c-4.388.772-14.79.65-19.504-.203c-10.28-1.828-20.033-6.908-26.047-13.572c-2.357-2.6-6.949-9.387-6.664-9.874c.122-.163 1.178-.813 2.356-1.504c1.138-.65 5.446-3.129 9.509-5.485l7.355-4.267l1.544 2.276c2.154 3.29 6.867 7.801 9.712 9.305c8.167 4.307 19.383 3.698 24.909-1.26c2.357-2.153 3.332-4.388 3.332-7.68c0-2.966-.366-4.266-1.91-6.501c-1.99-2.845-6.054-5.242-17.595-10.24c-13.206-5.69-18.895-9.224-24.096-14.832c-3.007-3.25-5.852-8.452-7.03-12.8c-.975-3.617-1.22-12.678-.447-16.335c2.723-12.76 12.353-21.659 26.25-24.3c4.51-.853 14.994-.528 19.424.569Z"
  /></svg>

================
File: frontend/src/vite-env.d.ts
================
/// <reference types="vite/client" />

declare module "*.elm" {
  export const Elm: any;
}

================
File: frontend/elm.json
================
{
    "type": "application",
    "source-directories": [
        "src"
    ],
    "elm-version": "0.19.1",
    "dependencies": {
        "direct": {
            "NoRedInk/elm-json-decode-pipeline": "1.0.1",
            "elm/browser": "1.0.2",
            "elm/core": "1.0.5",
            "elm/html": "1.0.0",
            "elm/http": "2.0.0",
            "elm/json": "1.1.3",
            "jinjor/elm-debounce": "3.0.0"
        },
        "indirect": {
            "elm/bytes": "1.0.8",
            "elm/file": "1.0.5",
            "elm/time": "1.0.0",
            "elm/url": "1.0.0",
            "elm/virtual-dom": "1.0.3"
        }
    },
    "test-dependencies": {
        "direct": {},
        "indirect": {}
    }
}

================
File: frontend/index.html
================
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dashboard</title>
</head>

<body>
  <div id="app"></div>
  <script type="module" src="/src/main.ts"></script>
</body>

</html>

================
File: frontend/package.json
================
{
  "name": "dash",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "bunx --bun vite",
    "build": "bunx --bun vite build",
    "preview": "bunx --bun vite preview",
    "start": "bun run server.ts"
  },
  "devDependencies": {
    "drizzle-kit": "^0.30.1",
    "typescript": "~5.6.2",
    "vite": "^6.0.1",
    "vite-plugin-elm": "^3.0.1"
  },
  "dependencies": {
    "@libsql/client": "^0.14.0",
    "autoprefixer": "^10.4.20",
    "dotenv": "^16.4.7",
    "drizzle-orm": "^0.38.2",
    "tailwindcss": "^3.4.16"
  }
}

================
File: frontend/postcss.config.cjs
================
module.exports = {
    plugins: [
        require("tailwindcss"),
        require("autoprefixer"),
    ],
};

================
File: frontend/tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx,elm}", // This will include all files in src with these extensions
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

================
File: frontend/vite.config.ts
================
import { defineConfig } from 'vite';
import elmPlugin from 'vite-plugin-elm';

export default defineConfig({
  plugins: [elmPlugin()],
  resolve: {
    extensions: ['.ts', '.js', '.elm']
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true
      }
    }
  },
  
  build: {
    // Build to the backend's static directory
    outDir: '../dist',
    emptyOutDir: true
  }
});

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?


.env

================
File: drizzle.config.ts
================
import { config } from 'dotenv';
import { defineConfig } from 'drizzle-kit';

config({ path: '.env' });

export default defineConfig({
  schema: './src/db/schema.ts',
  out: './migrations',
  dialect: 'turso',
  dbCredentials: {
    url: process.env.TURSO_DATABASE_URL!,
    authToken: process.env.TURSO_AUTH_TOKEN!,
  },
});

================
File: package.json
================
{
  "name": "dashboard-monorepo",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "NODE_ENV=development concurrently 'bun run dev:frontend' 'bun run dev:backend'",
    "dev:frontend": "cd frontend && bun run dev",
    "dev:backend": "cd backend && bun run dev",
    "build": "cd frontend && bun run build",
    "start": "NODE_ENV=production cd backend && bun run start"
  },
  "devDependencies": {
    "concurrently": "^8.2.2",
    "typescript": "~5.6.2"
  }
}

================
File: tree.txt
================
.
├── backend
│   ├── bun.lockb
│   ├── package.json
│   └── src
│       ├── db
│       │   ├── index.ts
│       │   ├── query.ts
│       │   └── schema.ts
│       └── index.ts
├── bun.lockb
├── dist
│   ├── assets
│   │   ├── index-DfGxPVii.css
│   │   └── index-DngGinJE.js
│   ├── index.html
│   └── vite.svg
├── drizzle.config.ts
├── frontend
│   ├── bun.lockb
│   ├── elm-stuff
│   │   └── 0.19.1
│   │       ├── Dashboard.elmi
│   │       ├── Dashboard.elmo
│   │       ├── d.dat
│   │       ├── i.dat
│   │       ├── lock
│   │       └── o.dat
│   ├── elm.json
│   ├── index.html
│   ├── package.json
│   ├── postcss.config.cjs
│   ├── public
│   │   └── vite.svg
│   ├── src
│   │   ├── Dashboard.elm
│   │   ├── main.ts
│   │   ├── style.css
│   │   ├── typescript.svg
│   │   └── vite-env.d.ts
│   ├── tailwind.config.js
│   └── vite.config.ts
├── package.json
├── repopack-output.txt
└── tree.txt

10 directories, 34 files
