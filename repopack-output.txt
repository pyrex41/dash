This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-12-16T18:19:18.977Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
elm-stuff/
  generated-code/
    elm-community/
      elm-test/
        0.19.1-revision7/
          dependencies.657a552a25d771946e44019daf17c02f015a79df79e90d57eb52721fa65f4125.json
          dependencies.7ed8010665012120200c83bf1a6655a3e9f66a5049b84c377dc07fcbbec7dc56.json
          dependencies.ea4acb9e915cd8e5c1e9a5997edd6e73ec9f754933a0bd0644eef92e600772d3.json
          elm.json
public/
  vite.svg
src/
  db/
    index.ts
    schema.ts
  counter.ts
  Dashboard.elm
  main.ts
  style.css
  typescript.svg
  vite-env.d.ts
.gitignore
drizzle.config.ts
elm.json
index.html
package.json
postcss.config.cjs
tailwind.config.js
vite.config.ts

================================================================
Repository Files
================================================================

================
File: elm-stuff/generated-code/elm-community/elm-test/0.19.1-revision7/dependencies.657a552a25d771946e44019daf17c02f015a79df79e90d57eb52721fa65f4125.json
================
{"direct":{"NoRedInk/elm-json-decode-pipeline":"1.0.1","elm/browser":"1.0.2","elm/core":"1.0.5","elm/html":"1.0.0","elm/json":"1.1.3","elm/random":"1.0.0","elm/time":"1.0.0","jinjor/elm-debounce":"3.0.0"},"indirect":{"elm/url":"1.0.0","elm/virtual-dom":"1.0.3"}}

================
File: elm-stuff/generated-code/elm-community/elm-test/0.19.1-revision7/dependencies.7ed8010665012120200c83bf1a6655a3e9f66a5049b84c377dc07fcbbec7dc56.json
================
{"direct":{"elm/browser":"1.0.2","elm/core":"1.0.5","elm/html":"1.0.0","elm/json":"1.1.3","elm/random":"1.0.0","elm/time":"1.0.0"},"indirect":{"elm/url":"1.0.0","elm/virtual-dom":"1.0.3"}}

================
File: elm-stuff/generated-code/elm-community/elm-test/0.19.1-revision7/dependencies.ea4acb9e915cd8e5c1e9a5997edd6e73ec9f754933a0bd0644eef92e600772d3.json
================
{"direct":{"NoRedInk/elm-json-decode-pipeline":"1.0.1","elm/browser":"1.0.2","elm/core":"1.0.5","elm/html":"1.0.0","elm/json":"1.1.3","elm/random":"1.0.0","elm/time":"1.0.0"},"indirect":{"elm/url":"1.0.0","elm/virtual-dom":"1.0.3"}}

================
File: elm-stuff/generated-code/elm-community/elm-test/0.19.1-revision7/elm.json
================
{
    "type": "application",
    "source-directories": [
        "src",
        "../../../../../../.config/yarn/global/node_modules/elm-test/elm/src",
        "../../../../../src"
    ],
    "elm-version": "0.19.1",
    "dependencies": {
        "direct": {
            "NoRedInk/elm-json-decode-pipeline": "1.0.1",
            "elm/browser": "1.0.2",
            "elm/core": "1.0.5",
            "elm/html": "1.0.0",
            "elm/json": "1.1.3",
            "elm/random": "1.0.0",
            "elm/time": "1.0.0",
            "jinjor/elm-debounce": "3.0.0"
        },
        "indirect": {
            "elm/url": "1.0.0",
            "elm/virtual-dom": "1.0.3"
        }
    },
    "test-dependencies": {
        "direct": {},
        "indirect": {}
    }
}

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: src/db/index.ts
================
import { drizzle } from 'drizzle-orm/libsql';
import { createClient } from '@libsql/client';
import { schema } from './schema';

const dbFile = 'file:./csg.db';
const tursoDbUrl = import.meta.env.VITE_TURSO_DATABASE_URL;
const tursoAuthToken = import.meta.env.VITE_TURSO_AUTH_TOKEN;

const client = createClient({
    url: tursoDbUrl,
    authToken: tursoAuthToken,
    // syncUrl: tursoDbUrl,
    // syncInterval: 60 // 60 seconds, adjust as needed
});

export const db = drizzle(client, { schema });

================
File: src/db/schema.ts
================
// /server/db/schema.ts
import { sql } from 'drizzle-orm';
import { sqliteTable, text, integer, unique, index } from 'drizzle-orm/sqlite-core';

export const user = sqliteTable('user', {
  id: text('id').primaryKey().notNull(),
  createdAt: integer('createdAt', { mode: 'timestamp' })
    .default(sql`(CURRENT_TIMESTAMP)`)
    .notNull(),
  updatedAt: integer('updatedAt', { mode: 'timestamp' })
    .default(sql`(CURRENT_TIMESTAMP)`)
    .notNull(),
  email: text('email'),
  isTemporary: integer('is_temporary', { mode: 'boolean' }).notNull().default(true),
  isAnonymous: integer('is_anonymous', { mode: 'boolean' }).notNull().default(true),
});

export const applications = sqliteTable(
  'applications',
  {
    id: text('id').primaryKey().notNull(),
    userId: text('user_id')
      .notNull()
      .references(() => user.id),
    status: text('status').notNull(),
    createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
    updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull(),
    data: text('data', { mode: 'json' }).$type<Record<string, any>>().notNull(),
    name: text('name'),
    naic: text('naic'),
    zip: text('zip').notNull(),
    county: text('county').notNull(),
    dob: text('dob').notNull(),
    schema: text('schema', { mode: 'json' }).$type<Record<string, any>>().notNull(),
    originalSchema: text('original_schema', { mode: 'json' }).$type<Record<string, any>>().notNull(),
    underwritingType: integer('underwriting_type').notNull().default(0),
  },
  (table) => ({
    csgKeyIndex: index('idx_applications_csg_key').on(table.id),
    underwritingTypeCheck: sql`CHECK (underwriting_type IN (0, 1, 2))`
  })
);

export const csgApplications = sqliteTable(
  'csg_applications',
  {
    id: integer('id').primaryKey({ autoIncrement: true }),
    applicationId: text('application_id')
      .notNull()
      .references(() => applications.id),
    key: text('key').notNull(),
    responseBody: text('response_body').notNull(),
    brokerEmail: text('broker_email'),
    createdAt: integer('created_at', { mode: 'timestamp' })
      .notNull()
      .default(sql`CURRENT_TIMESTAMP`),
    updatedAt: integer('updated_at', { mode: 'timestamp' })
      .notNull()
      .default(sql`CURRENT_TIMESTAMP`),
  },
  (table) => ({
    applicationIdIndex: index('idx_csg_applications_application_id').on(table.applicationId),
    keyIndex: index('idx_csg_applications_key').on(table.key),
  })
);

export const onboarding = sqliteTable('onboarding', {
  id: text('id').primaryKey(),
  userId: text('user_id')
    .notNull()
    .references(() => user.id),
  createdAt: integer('created_at', { mode: 'timestamp' })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
  updatedAt: integer('updated_at', { mode: 'timestamp' })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
  data: text('data', { mode: 'json' }).notNull(),
});

export const csgTokens = sqliteTable('csg_tokens', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  token: text('token').notNull(),
  expiresAt: integer('expires_at', { mode: 'timestamp' }).notNull(),
  createdAt: integer('created_at', { mode: 'timestamp' })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
  updatedAt: integer('updated_at', { mode: 'timestamp' })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
}, (table) => ({
  tokenIndex: index('idx_csg_tokens_token').on(table.token),
  expiresAtIndex: index('idx_csg_tokens_expires_at').on(table.expiresAt),
}));

export const brokers = sqliteTable('brokers', {
  id: text('id').primaryKey(),
  username: text('username').notNull().unique(),
  passwordHash: text('password_hash').notNull(),
  createdAt: integer('created_at', { mode: 'timestamp' })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
  updatedAt: integer('updated_at', { mode: 'timestamp' })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
});

export const bookings = sqliteTable('bookings', {
  id: text('id').primaryKey().notNull(),
  userId: text('user_id')
    .references(() => user.id),
  applicationId: text('application_id')
    .references(() => applications.id),
  email: text('email').notNull(),
  phone: text('phone'),
  url: text('url').notNull(),
  event: text('event'),
  status: text('status').notNull(),
  createdAt: text('created_at')
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
  updatedAt: text('updated_at')
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
}, (table) => ({
  userIdIndex: index('idx_bookings_user_id').on(table.userId),
  emailIndex: index('idx_bookings_email').on(table.email),
  applicationIdIndex: index('idx_bookings_application_id').on(table.applicationId),
}));

export const schema = {
  user,
  applications,
  csgApplications,
  onboarding,
  csgTokens,
  brokers,
  bookings
};

================
File: src/counter.ts
================
export function setupCounter(element: HTMLButtonElement) {
  let counter = 0
  const setCounter = (count: number) => {
    counter = count
    element.innerHTML = `count is ${counter}`
  }
  element.addEventListener('click', () => setCounter(counter + 1))
  setCounter(0)
}

================
File: src/Dashboard.elm
================
port module Dashboard exposing (Model, Msg, init, update, view)

import Browser
import Debounce exposing (Debounce)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Json.Decode as Decode
import Json.Decode.Pipeline as Pipeline



-- PORTS


type alias PaginationInfo =
    { total : Int
    , page : Int
    , pageSize : Int
    , totalPages : Int
    }


type alias ApplicationsResponse =
    { applications : List Application
    , pagination : PaginationInfo
    }


port receiveApplications : (Decode.Value -> msg) -> Sub msg


port requestRefresh : { page : Int, pageSize : Int, searchTerm : String, hasContactFilter : Bool } -> Cmd msg


port exportToCsv : { searchTerm : String, hasContactFilter : Bool, hasCSGFilter : Bool } -> Cmd msg



-- MAIN


main =
    Browser.element
        { init = init
        , update = update
        , subscriptions = subscriptions
        , view = view
        }



-- MODEL


type alias Model =
    { quoteSent : Int
    , submissions : Int
    , waitingReview : Int
    , completedApps : Int
    , applications : List Application
    , searchTerm : String
    , hasContactFilter : Bool
    , hasCSGFilter : Bool
    , isLoading : Bool
    , error : Maybe String
    , searchDebouncer : Debounce String
    , searchLoading : Bool
    , currentPage : Int
    , pageSize : Int
    , total : Int
    , totalPages : Int
    }


type alias Application =
    { id : String
    , userId : String
    , userEmail : Maybe String
    , createdAt : String
    , dateStarted : String
    , dateCompleted : Maybe String
    , status : Status
    , state : Maybe String
    , data : Decode.Value
    , carrier : String
    , booking : Maybe Booking
    , csgApplication : Maybe CsgApplication
    }


type alias CsgApplication =
    { key : String
    , brokerEmail : Maybe String
    }


type alias Booking =
    { email : String
    , phone : Maybe String
    , url : String
    , status : String
    }


type Status
    = CompletedApp
    | WaitingReview
    | QuoteSent
    | SubmittedToCSG
    | CallBooked



-- INIT


init : () -> ( Model, Cmd Msg )
init _ =
    ( { quoteSent = 0
      , submissions = 0
      , waitingReview = 0
      , completedApps = 0
      , applications = []
      , searchTerm = ""
      , hasContactFilter = False
      , hasCSGFilter = False
      , isLoading = True
      , error = Nothing
      , searchDebouncer = Debounce.init
      , searchLoading = False
      , currentPage = 0
      , pageSize = 20
      , total = 0
      , totalPages = 0
      }
    , requestRefresh
        { page = 0
        , pageSize = 20
        , searchTerm = ""
        , hasContactFilter = False
        }
    )



-- UPDATE


type Msg
    = NoOp
    | ViewApplication String
    | CompleteApplication String
    | SearchTermChanged String
    | ToggleContactFilter Bool
    | ToggleCSGFilter Bool
    | RefreshApplications
    | ApplicationsReceived (Result Decode.Error ApplicationsResponse)
    | ExportToCsv
    | SearchDebouncerMsg Debounce.Msg
    | PerformSearch String
    | ChangePage Int


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        NoOp ->
            ( model, Cmd.none )

        ViewApplication id ->
            ( model, Cmd.none )

        CompleteApplication id ->
            ( model, Cmd.none )

        SearchTermChanged term ->
            let
                trimmedTerm =
                    String.trim term

                shouldSearch =
                    String.length trimmedTerm >= 3

                shouldRefresh =
                    String.length trimmedTerm == 0 && String.length (String.trim model.searchTerm) > 0

                ( debouncer, cmd ) =
                    if shouldSearch then
                        Debounce.push searchDebounceConfig trimmedTerm model.searchDebouncer

                    else if shouldRefresh then
                        ( model.searchDebouncer
                        , requestRefresh
                            { page = 0
                            , pageSize = 20
                            , searchTerm = ""
                            , hasContactFilter = False
                            }
                        )

                    else
                        ( model.searchDebouncer, Cmd.none )
            in
            ( { model
                | searchTerm = term
                , searchDebouncer = debouncer
                , searchLoading = shouldSearch
                , isLoading = shouldRefresh
              }
            , cmd
            )

        SearchDebouncerMsg debouncerMsg ->
            let
                ( debouncer, cmd ) =
                    Debounce.update
                        searchDebounceConfig
                        (Debounce.takeLast performSearch)
                        debouncerMsg
                        model.searchDebouncer
            in
            ( { model | searchDebouncer = debouncer }
            , cmd
            )

        ToggleContactFilter value ->
            ( { model | hasContactFilter = value, isLoading = True }
            , requestRefresh
                { page = model.currentPage
                , pageSize = model.pageSize
                , searchTerm = model.searchTerm
                , hasContactFilter = value
                }
            )

        ToggleCSGFilter value ->
            ( { model | hasCSGFilter = value }, Cmd.none )

        RefreshApplications ->
            ( { model | isLoading = True }, requestRefresh { page = 0, pageSize = 20, searchTerm = "", hasContactFilter = False } )

        ApplicationsReceived (Ok response) ->
            ( { model
                | applications = response.applications
                , isLoading = False
                , searchLoading = False
                , quoteSent = List.length (List.filter (\a -> a.status == QuoteSent) response.applications)
                , submissions = List.length (List.filter (\a -> a.status == QuoteSent) response.applications)
                , waitingReview = List.length (List.filter (\a -> a.status == WaitingReview) response.applications)
                , completedApps = List.length (List.filter (\a -> a.status == CompletedApp) response.applications)
                , total = response.pagination.total
                , totalPages = response.pagination.totalPages
                , currentPage = response.pagination.page
                , pageSize = response.pagination.pageSize
              }
            , Cmd.none
            )

        ApplicationsReceived (Err _) ->
            ( { model | error = Just "Failed to load applications", isLoading = False, searchLoading = False }, Cmd.none )

        ExportToCsv ->
            ( model
            , exportToCsv
                { searchTerm = model.searchTerm
                , hasContactFilter = model.hasContactFilter
                , hasCSGFilter = model.hasCSGFilter
                }
            )

        PerformSearch term ->
            ( model
            , requestRefresh
                { page = 0
                , pageSize = 20
                , searchTerm = term
                , hasContactFilter = False
                }
            )

        ChangePage page ->
            ( { model | currentPage = page, isLoading = True }
            , requestRefresh
                { page = page
                , pageSize = model.pageSize
                , searchTerm = model.searchTerm
                , hasContactFilter = False
                }
            )



-- Add completion logic here
-- VIEW


view : Model -> Html Msg
view model =
    div [ class "min-h-screen bg-white" ]
        [ viewHeader
        , div [ class "max-w-7xl mx-auto" ]
            [ viewMetrics model
            , viewApplications model
            ]
        ]


viewHeader : Html Msg
viewHeader =
    header [ class "border-b" ]
        [ div [ class "max-w-7xl mx-auto flex justify-between items-center p-4" ]
            [ div [ class "flex items-center gap-4" ]
                [ h1 [ class "text-xl font-bold" ] [ text "White Labeled Logo" ]
                , nav [ class "flex gap-4" ]
                    [ a [ href "#" ] [ text "Medigap Applications" ]
                    , a [ href "#" ] [ text "Contacts" ]
                    ]
                ]
            , div [ class "flex items-center gap-4" ]
                [ button [ class "bg-black text-white px-4 py-2 rounded" ]
                    [ text "Send Something" ]
                , div [ class "flex items-center gap-2" ]
                    [ span [ class "w-8 h-8 bg-gray-200 rounded-full flex items-center justify-center" ]
                        [ text "J" ]
                    , text "John Doe"
                    ]
                ]
            ]
        ]


viewMetrics : Model -> Html Msg
viewMetrics model =
    div [ class "grid grid-cols-4 gap-4 p-4" ]
        [ viewMetricCard "Quote Sent" model.quoteSent "80" "up"
        , viewMetricCard "Submissions" model.submissions "20" "up"
        , viewMetricCard "Waiting Review" model.waitingReview "10" "down"
        , viewMetricCard "Completed Apps" model.completedApps "" ""
        ]


viewMetricCard : String -> Int -> String -> String -> Html Msg
viewMetricCard title value percentage direction =
    div [ class "p-4 rounded-lg border" ]
        [ div [ class "text-sm text-gray-600" ] [ text title ]
        , div [ class "text-3xl font-bold" ] [ text (String.fromInt value) ]
        , if percentage /= "" then
            div
                [ class
                    ("text-sm "
                        ++ (if direction == "up" then
                                "text-green-500"

                            else
                                "text-red-500"
                           )
                    )
                ]
                [ text (percentage ++ "% vs last month") ]

          else
            text ""
        ]


viewApplications : Model -> Html Msg
viewApplications model =
    div [ class "p-4" ]
        [ div [ class "flex justify-between items-center mb-4" ]
            [ h2 [ class "text-xl" ] [ text "Applications" ]
            , div [ class "flex gap-4 items-center" ]
                [ label [ class "flex items-center gap-2 text-sm text-gray-600" ]
                    [ input
                        [ type_ "checkbox"
                        , class "rounded border-gray-300"
                        , checked model.hasContactFilter
                        , onCheck ToggleContactFilter
                        ]
                        []
                    , text "Has contact info"
                    ]
                , div [ class "relative" ]
                    [ input
                        [ class "px-3 py-1 border rounded"
                        , placeholder "Search"
                        , type_ "search"
                        , value model.searchTerm
                        , onInput SearchTermChanged
                        ]
                        []
                    , if model.searchLoading && String.length model.searchTerm >= 3 then
                        div
                            [ class "absolute right-2 top-1/2 transform -translate-y-1/2" ]
                            [ div
                                [ class "animate-spin h-4 w-4 border-2 border-gray-300 border-t-purple-600 rounded-full" ]
                                []
                            ]

                      else
                        text ""
                    ]
                ]
            ]
        , if model.isLoading then
            div [ class "flex justify-center items-center py-8" ]
                [ div [ class "animate-spin rounded-full h-12 w-12 border-b-2 border-purple-600" ] []
                , span [ class "sr-only" ] [ text "Loading..." ]
                ]

          else
            div []
                [ table [ class "w-full border-collapse" ]
                    [ thead []
                        [ tr [ class "border-b text-left" ]
                            [ th [ class "w-8 py-3 px-4" ]
                                [ input [ type_ "checkbox", class "rounded border-gray-300" ] [] ]
                            , th [ class "py-3 px-4 font-medium text-sm text-gray-600 w-48" ] [ text "Name" ]
                            , th [ class "py-3 px-4 font-medium text-sm text-gray-600 w-32" ] [ text "Carrier" ]
                            , th [ class "py-3 px-4 font-medium text-sm text-gray-600 w-32" ] [ text "Status" ]
                            , th [ class "py-3 px-4 font-medium text-sm text-gray-600 w-36" ] [ text "Phone Number" ]
                            , th [ class "py-3 px-4 font-medium text-sm text-gray-600 w-48" ] [ text "Email address" ]
                            , th [ class "py-3 px-4 font-medium text-sm text-gray-600 w-28" ] [ text "Date Started" ]
                            , th [ class "py-3 px-4 font-medium text-sm text-gray-600 w-28" ] [ text "Date Completed" ]
                            , th [ class "py-3 px-4 font-medium text-sm text-gray-600 w-24" ] [ text "" ]
                            ]
                        ]
                    , tbody []
                        (List.map viewApplicationRow model.applications)
                    ]
                , viewPagination model
                ]
        ]


viewApplicationRow : Application -> Html Msg
viewApplicationRow app =
    let
        getName =
            let
                firstName =
                    app.data
                        |> Decode.decodeValue (Decode.at [ "applicant_info", "f_name" ] Decode.string)
                        |> Result.toMaybe
                        |> Maybe.withDefault ""

                lastName =
                    app.data
                        |> Decode.decodeValue (Decode.at [ "applicant_info", "l_name" ] Decode.string)
                        |> Result.toMaybe
                        |> Maybe.withDefault ""
            in
            String.trim (firstName ++ " " ++ lastName)

        getApplicantInfo field =
            app.data
                |> Decode.decodeValue (Decode.at [ "applicant_info", field ] Decode.string)
                |> Result.toMaybe

        getEmail =
            [ app.userEmail -- From user
            , getApplicantInfo "email" -- From application data
            , Maybe.map .email app.booking -- From booking
            ]
                |> List.filterMap identity
                |> List.head
                |> Maybe.withDefault ""

        getPhone =
            [ getApplicantInfo "phone" -- From application data
            , Maybe.andThen .phone app.booking -- From booking
            ]
                |> List.filterMap identity
                |> List.head
                |> Maybe.withDefault ""

        formatDate dateString =
            dateString
                |> String.split "T"
                |> List.head
                |> Maybe.withDefault dateString
    in
    tr [ class "border-b hover:bg-gray-50" ]
        [ td [ class "py-3 px-4 w-8" ]
            [ input [ type_ "checkbox", class "rounded border-gray-300" ] [] ]
        , td [ class "py-3 px-4 w-48" ] [ text getName ]
        , td [ class "py-3 px-4 w-32" ] [ text app.carrier ]
        , td [ class "py-3 px-4 w-32" ] [ viewStatus app.status ]
        , td [ class "py-3 px-4 text-gray-600 w-36 whitespace-nowrap" ] [ text getPhone ]
        , td [ class "py-3 px-4 text-gray-600 w-48 truncate" ] [ text getEmail ]
        , td [ class "py-3 px-4 text-gray-600 w-28 whitespace-nowrap" ] [ text (formatDate app.dateStarted) ]
        , td [ class "py-3 px-4 text-gray-600 w-28 whitespace-nowrap" ]
            [ text (app.dateCompleted |> Maybe.map formatDate |> Maybe.withDefault "") ]
        , td [ class "py-3 px-4 w-24" ]
            [ button
                [ class "bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-md text-sm"
                , onClick (ViewApplication app.id)
                ]
                [ text "View" ]
            ]
        ]


viewStatus : Status -> Html Msg
viewStatus status =
    let
        ( statusText, statusColor ) =
            case status of
                CompletedApp ->
                    ( "Completed App", "text-green-600 bg-green-50" )

                WaitingReview ->
                    ( "Waiting Review", "text-red-600 bg-red-50" )

                QuoteSent ->
                    ( "Started", "text-blue-600 bg-blue-50" )

                SubmittedToCSG ->
                    ( "Submitted to CSG", "text-purple-600 bg-purple-50" )

                CallBooked ->
                    ( "Intro Call", "text-orange-600 bg-orange-50" )
    in
    div [ class ("flex items-center gap-2 " ++ statusColor ++ " px-3 py-1 rounded-full w-fit") ]
        [ div [ class "w-2 h-2 rounded-full bg-current" ] []
        , span [ class "text-sm" ] [ text statusText ]
        ]



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions _ =
    receiveApplications
        (Decode.decodeValue applicationListDecoder >> ApplicationsReceived)



-- DECODERS
{--
jdebug : String -> Decode.Decoder a -> Decode.Decoder a
jdebug message decoder =
    Decode.value
        |> Decode.andThen (debugHelper message decoder)


debugHelper : String -> Decode.Decoder a -> Decode.Value -> Decode.Decoder a
debugHelper message decoder value =
    let
        _ =
            Debug.log message (Decode.decodeValue decoder value)
    in
    decoder
--}


applicationDecoder : Decode.Decoder Application
applicationDecoder =
    Decode.succeed Application
        |> Pipeline.required "id" Decode.string
        |> Pipeline.required "userId" Decode.string
        |> Pipeline.optional "userEmail" (Decode.nullable Decode.string) Nothing
        |> Pipeline.required "createdAt" Decode.string
        |> Pipeline.required "dateStarted" Decode.string
        |> Pipeline.optional "dateCompleted" (Decode.nullable Decode.string) Nothing
        |> Pipeline.required "status" statusDecoder
        |> Pipeline.optional "state" (Decode.nullable Decode.string) Nothing
        |> Pipeline.required "data" Decode.value
        |> Pipeline.required "name" (Decode.map cleanCarrierName Decode.string)
        |> Pipeline.optional "booking" (Decode.nullable bookingDecoder) Nothing
        |> Pipeline.optional "csgApplication" (Decode.nullable csgApplicationDecoder) Nothing



-- |> jdebug "Application Decoder"


applicationListDecoder : Decode.Decoder ApplicationsResponse
applicationListDecoder =
    Decode.map2 ApplicationsResponse
        (Decode.field "applications" (Decode.list applicationDecoder))
        (Decode.field "pagination" paginationDecoder)



-- |> jdebug "Application List Decoder"


paginationDecoder : Decode.Decoder PaginationInfo
paginationDecoder =
    Decode.map4 PaginationInfo
        (Decode.field "total" Decode.int)
        (Decode.field "page" Decode.int)
        (Decode.field "pageSize" Decode.int)
        (Decode.field "totalPages" Decode.int)



-- |> jdebug "Pagination Decoder"


statusDecoder : Decode.Decoder Status
statusDecoder =
    Decode.string
        |> Decode.andThen
            (\str ->
                case str of
                    "completed" ->
                        Decode.succeed CompletedApp

                    "review" ->
                        Decode.succeed WaitingReview

                    "quote" ->
                        Decode.succeed QuoteSent

                    "submitted_to_csg" ->
                        Decode.succeed SubmittedToCSG

                    "call_booked" ->
                        Decode.succeed CallBooked

                    _ ->
                        Decode.succeed QuoteSent
            )



-- |> jdebug "Status Decoder"


bookingDecoder : Decode.Decoder Booking
bookingDecoder =
    Decode.succeed Booking
        |> Pipeline.required "email" Decode.string
        |> Pipeline.optional "phone" (Decode.nullable Decode.string) Nothing
        |> Pipeline.required "url" Decode.string
        |> Pipeline.required "status" Decode.string



-- |> jdebug "Booking Decoder"


csgApplicationDecoder : Decode.Decoder CsgApplication
csgApplicationDecoder =
    Decode.succeed CsgApplication
        |> Pipeline.required "key" Decode.string
        |> Pipeline.optional "brokerEmail" (Decode.nullable Decode.string) Nothing



-- |> jdebug "CSG Application Decoder"


cleanCarrierName : String -> String
cleanCarrierName name =
    name
        |> String.replace " Application" ""



-- Debounce config


searchDebounceConfig : Debounce.Config Msg
searchDebounceConfig =
    { strategy = Debounce.later 300
    , transform = SearchDebouncerMsg
    }



-- Helper function to perform the actual search


performSearch : String -> Cmd Msg
performSearch term =
    requestRefresh
        { page = 0
        , pageSize = 20
        , searchTerm = term
        , hasContactFilter = False
        }


viewPagination : Model -> Html Msg
viewPagination model =
    div [ class "mt-4 flex items-center justify-between border-t border-gray-200 px-4 py-3 sm:px-6" ]
        [ div [ class "flex flex-1 justify-between sm:hidden" ]
            [ button
                [ class "relative inline-flex items-center rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
                , onClick (ChangePage (model.currentPage - 1))
                , disabled (model.currentPage <= 0)
                ]
                [ text "Previous" ]
            , button
                [ class "relative ml-3 inline-flex items-center rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
                , onClick (ChangePage (model.currentPage + 1))
                , disabled (model.currentPage >= model.totalPages - 1)
                ]
                [ text "Next" ]
            ]
        , div [ class "hidden sm:flex sm:flex-1 sm:items-center sm:justify-between" ]
            [ div [ class "text-sm text-gray-700" ]
                [ span [] [ text "Showing " ]
                , span [ class "font-medium" ]
                    [ text (String.fromInt (model.currentPage * model.pageSize + 1))
                    , text " to "
                    , text (String.fromInt (Basics.min ((model.currentPage + 1) * model.pageSize) model.total))
                    ]
                , span [] [ text " of " ]
                , span [ class "font-medium" ] [ text (String.fromInt model.total) ]
                , span [] [ text " results" ]
                ]
            , div [ class "flex items-center gap-2" ]
                [ viewPageButtons model ]
            ]
        ]


viewPageButtons : Model -> Html Msg
viewPageButtons model =
    let
        pageNumbers =
            List.range 0 (model.totalPages - 1)
                |> List.filter
                    (\page ->
                        page
                            == 0
                            || page
                            == model.totalPages
                            - 1
                            || abs (page - model.currentPage)
                            <= 1
                    )
                |> List.sort
    in
    div [ class "flex gap-1" ]
        (List.map (viewPageButton model.currentPage) pageNumbers)


viewPageButton : Int -> Int -> Html Msg
viewPageButton currentPage page =
    button
        [ class
            (if page == currentPage then
                "relative inline-flex items-center px-4 py-2 text-sm font-semibold text-white bg-purple-600 focus:z-20 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-purple-600"

             else
                "relative inline-flex items-center px-4 py-2 text-sm font-semibold text-gray-900 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0"
            )
        , onClick (ChangePage page)
        ]
        [ text (String.fromInt (page + 1)) ]

================
File: src/main.ts
================
import './style.css'
import { Elm } from './Dashboard.elm'
import { db } from './db'
import { applications, bookings, user, csgApplications } from './db/schema'
import { desc, eq, sql } from 'drizzle-orm'

// Define TypeScript types that match Elm's expectations
type Application = {
  id: string
  userId: string
  userEmail: string | null
  createdAt: string
  dateStarted: string
  dateCompleted: string | null
  status: 'quote' | 'review' | 'completed' | 'submitted_to_csg' | 'call_booked'
  state: string | null
  data: Record<string, any>
  name: string
  booking: {
    email: string
    phone: string | null
    url: string
    status: string
  } | null
  csgApplication: {
    key: string
    brokerEmail: string | null
  } | null
}

type PaginationRequest = {
  page: number
  pageSize: number
  searchTerm: string
  hasContactFilter: boolean
}

const app = Elm.Dashboard.init({
  node: document.getElementById('app')
})

// Helper function to format application data for Elm
const formatApplicationData = async (rawApplications: any[]): Promise<Application[]> => {
  // Get all related bookings for these applications
  const applicationIds = rawApplications.map(app => app.id)
  const relatedBookings = await db
    .select()
    .from(bookings)
    .where(sql`application_id IN ${applicationIds}`)

  // Get all related users
  const userIds = rawApplications.map(app => app.userId)
  const relatedUsers = await db
    .select()
    .from(user)
    .where(sql`id IN ${userIds}`)

  // Get related CSG applications
  const relatedCsgApps = await db
    .select()
    .from(csgApplications)
    .where(sql`application_id IN ${applicationIds}`)

  // Create lookup maps
  const bookingsByAppId = new Map(
    relatedBookings.map(booking => [booking.applicationId, booking])
  )
  const usersById = new Map(
    relatedUsers.map(user => [user.id, user])
  )
  const csgAppsByAppId = new Map(
    relatedCsgApps.map(csgApp => [csgApp.applicationId, csgApp])
  )

  return rawApplications.map(app => {
    const relatedBooking = bookingsByAppId.get(app.id)
    const relatedUser = usersById.get(app.userId)
    const relatedCsgApp = csgAppsByAppId.get(app.id)

    const safeDate = (dateStr: string | number): string => {
      try {
        return new Date(dateStr).toISOString();
      } catch {
        return String(dateStr);
      }
    }

    // Determine the status based on the new rules
    let status = determineStatus(app.status, !!relatedCsgApp, !!relatedBooking)

    return {
      id: app.id,
      userId: app.userId,
      userEmail: relatedUser?.email || null,
      createdAt: safeDate(app.createdAt),
      dateStarted: safeDate(app.createdAt),
      dateCompleted: null,
      status,
      state: null,
      data: typeof app.data === 'string' ? JSON.parse(app.data) : app.data,
      name: app.name || 'Unknown',
      booking: relatedBooking ? {
        email: relatedBooking.email,
        phone: relatedBooking.phone,
        url: relatedBooking.url,
        status: relatedBooking.status
      } : null,
      csgApplication: relatedCsgApp ? {
        key: relatedCsgApp.key,
        brokerEmail: relatedCsgApp.brokerEmail
      } : null
    }
  })
}

// Helper function to determine status
const determineStatus = (
  status: string,
  hasCsgApp: boolean,
  hasBooking: boolean
): 'completed' | 'review' | 'quote' | 'submitted_to_csg' | 'call_booked' => {
  if (hasCsgApp) {
    return 'submitted_to_csg'
  }
  if (hasBooking) {
    return 'call_booked'
  }
  
  switch (status.toLowerCase()) {
    case 'completed':
      return 'completed'
    case 'review':
      return 'review'
    default:
      return 'quote'
  }
}

// Listen for refresh requests from Elm
app.ports.requestRefresh?.subscribe(async (request: PaginationRequest) => {
  try {
    const { page, pageSize, searchTerm, hasContactFilter } = request
    
    const shouldSearch = searchTerm.length >= 3;
    const offset = page * pageSize
    const searchPattern = `%${searchTerm.toLowerCase()}%`

    // Build the base query
    let query = db
      .select({
        id: applications.id,
        userId: applications.userId,
        status: applications.status,
        createdAt: applications.createdAt,
        updatedAt: applications.updatedAt,
        data: applications.data,
        name: applications.name,
      })
      .from(applications)

    // Add contact filter condition if enabled
    if (hasContactFilter) {
      query = query.where(
        sql`(
          -- Check for email or phone in application data
          json_extract(${applications.data}, '$.applicant_info.email') IS NOT NULL OR
          json_extract(${applications.data}, '$.applicant_info.phone') IS NOT NULL OR
          -- Check for email or phone in bookings
          EXISTS (
            SELECT 1 FROM ${bookings}
            WHERE ${bookings.applicationId} = ${applications.id}
            AND (${bookings.email} IS NOT NULL OR ${bookings.phone} IS NOT NULL)
          ) OR
          -- Check for user email
          EXISTS (
            SELECT 1 FROM ${user}
            WHERE ${user.id} = ${applications.userId}
            AND ${user.email} IS NOT NULL
          )
        )`
      )
    }

    // Add search conditions if there's a search term
    if (searchTerm && shouldSearch) {
      query = query.where(
        sql`(
          -- Search in application data JSON
          LOWER(json_extract(${applications.data}, '$.applicant_info.f_name')) LIKE ${searchPattern} OR
          LOWER(json_extract(${applications.data}, '$.applicant_info.l_name')) LIKE ${searchPattern} OR
          LOWER(json_extract(${applications.data}, '$.applicant_info.phone')) LIKE ${searchPattern} OR
          LOWER(json_extract(${applications.data}, '$.applicant_info.email')) LIKE ${searchPattern} OR
          -- Search in carrier name
          LOWER(${applications.name}) LIKE ${searchPattern} OR
          -- Search in related bookings
          EXISTS (
            SELECT 1 FROM ${bookings}
            WHERE ${bookings.applicationId} = ${applications.id}
            AND (
              LOWER(${bookings.email}) LIKE ${searchPattern}
              ${bookings.phone ? sql`OR LOWER(${bookings.phone}) LIKE ${searchPattern}` : sql``}
            )
          ) OR
          -- Search in related users
          EXISTS (
            SELECT 1 FROM ${user}
            WHERE ${user.id} = ${applications.userId}
            AND LOWER(${user.email}) LIKE ${searchPattern}
          )
        )`
      )
    }

    // Add ordering and pagination
    const results = await query
      .orderBy(desc(applications.createdAt))
      .limit(pageSize)
      .offset(offset)

    // Get total count with the same conditions as the main query
    let countQuery = db
      .select({ count: sql`count(*)`.mapWith(Number) })
      .from(applications)

    // Add contact filter condition to count query if enabled
    if (hasContactFilter) {
      countQuery = countQuery.where(
        sql`(
          json_extract(${applications.data}, '$.applicant_info.email') IS NOT NULL OR
          json_extract(${applications.data}, '$.applicant_info.phone') IS NOT NULL OR
          EXISTS (
            SELECT 1 FROM ${bookings}
            WHERE ${bookings.applicationId} = ${applications.id}
            AND (${bookings.email} IS NOT NULL OR ${bookings.phone} IS NOT NULL)
          ) OR
          EXISTS (
            SELECT 1 FROM ${user}
            WHERE ${user.id} = ${applications.userId}
            AND ${user.email} IS NOT NULL
          )
        )`
      )
    }

    // Add search conditions to count query if there's a search term
    if (searchTerm && shouldSearch) {
      countQuery = countQuery.where(
        sql`(
          LOWER(json_extract(${applications.data}, '$.applicant_info.f_name')) LIKE ${searchPattern} OR
          LOWER(json_extract(${applications.data}, '$.applicant_info.l_name')) LIKE ${searchPattern} OR
          LOWER(json_extract(${applications.data}, '$.applicant_info.phone')) LIKE ${searchPattern} OR
          LOWER(json_extract(${applications.data}, '$.applicant_info.email')) LIKE ${searchPattern} OR
          LOWER(${applications.name}) LIKE ${searchPattern} OR
          EXISTS (
            SELECT 1 FROM ${bookings}
            WHERE ${bookings.applicationId} = ${applications.id}
            AND (
              LOWER(${bookings.email}) LIKE ${searchPattern}
              ${bookings.phone ? sql`OR LOWER(${bookings.phone}) LIKE ${searchPattern}` : sql``}
            )
          ) OR
          EXISTS (
            SELECT 1 FROM ${user}
            WHERE ${user.id} = ${applications.userId}
            AND LOWER(${user.email}) LIKE ${searchPattern}
          )
        )`
      )
    }

    const [{ count }] = await countQuery

    // Format the data for Elm
    const formattedApplications = await formatApplicationData(results)

    // Send the data back to Elm
    app.ports.receiveApplications.send({
      applications: formattedApplications,
      pagination: {
        total: count,
        page,
        pageSize,
        totalPages: Math.ceil(count / pageSize)
      }
    })
  } catch (error) {
    console.error('Error fetching applications:', error)
  }
})

// Handle CSV export requests
app.ports.exportToCsv?.subscribe(async ({ searchTerm, hasContactFilter, hasCSGFilter }) => {
  try {
    let query = db
      .select({
        id: applications.id,
        name: applications.name,
        status: applications.status,
        createdAt: applications.createdAt,
        updatedAt: applications.updatedAt,
        data: applications.data,
      })
      .from(applications)
      .orderBy(desc(applications.createdAt))

    if (searchTerm) {
      query = query.where(sql`name LIKE ${`%${searchTerm}%`}`)
    }

    const results = await query
    const formattedResults = await formatApplicationData(results)
    
    // Convert results to CSV
    const csvContent = convertToCSV(formattedResults)
    downloadCSV(csvContent, 'applications-export.csv')
  } catch (error) {
    console.error('Error exporting to CSV:', error)
  }
})

function convertToCSV(data: Application[]): string {
  const headers = ['ID', 'Name', 'Carrier', 'Status', 'Email', 'Phone', 'Date Started', 'Date Completed']
  const rows = data.map(item => {
    const applicantInfo = item.data?.applicant_info || {}
    const fullName = `${applicantInfo.f_name || ''} ${applicantInfo.l_name || ''}`.trim()
    
    return [
      item.id,
      fullName,
      item.name,
      item.status,
      item.booking?.email || item.userEmail || '',
      item.booking?.phone || '',
      new Date(item.dateStarted).toLocaleDateString(),
      item.dateCompleted ? new Date(item.dateCompleted).toLocaleDateString() : ''
    ]
  })
  
  return [
    headers.join(','),
    ...rows.map(row => row.join(','))
  ].join('\n')
}

function downloadCSV(content: string, filename: string) {
  const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' })
  const link = document.createElement('a')
  link.href = URL.createObjectURL(blob)
  link.download = filename
  link.click()
  URL.revokeObjectURL(link.href)
}

================
File: src/style.css
================
@import "tailwindcss/base";
@import "tailwindcss/components";
@import "tailwindcss/utilities";

================
File: src/typescript.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="32" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path fill="#007ACC" d="M0 128v128h256V0H0z"></path><path fill="#FFF" d="m56.612 128.85l-.081 10.483h33.32v94.68h23.568v-94.68h33.321v-10.28c0-5.69-.122-10.444-.284-10.566c-.122-.162-20.4-.244-44.983-.203l-44.74.122l-.121 10.443Zm149.955-10.742c6.501 1.625 11.459 4.51 16.01 9.224c2.357 2.52 5.851 7.111 6.136 8.208c.08.325-11.053 7.802-17.798 11.988c-.244.162-1.22-.894-2.317-2.52c-3.291-4.795-6.745-6.867-12.028-7.233c-7.76-.528-12.759 3.535-12.718 10.321c0 1.992.284 3.17 1.097 4.795c1.707 3.536 4.876 5.649 14.832 9.956c18.326 7.883 26.168 13.084 31.045 20.48c5.445 8.249 6.664 21.415 2.966 31.208c-4.063 10.646-14.14 17.879-28.323 20.276c-4.388.772-14.79.65-19.504-.203c-10.28-1.828-20.033-6.908-26.047-13.572c-2.357-2.6-6.949-9.387-6.664-9.874c.122-.163 1.178-.813 2.356-1.504c1.138-.65 5.446-3.129 9.509-5.485l7.355-4.267l1.544 2.276c2.154 3.29 6.867 7.801 9.712 9.305c8.167 4.307 19.383 3.698 24.909-1.26c2.357-2.153 3.332-4.388 3.332-7.68c0-2.966-.366-4.266-1.91-6.501c-1.99-2.845-6.054-5.242-17.595-10.24c-13.206-5.69-18.895-9.224-24.096-14.832c-3.007-3.25-5.852-8.452-7.03-12.8c-.975-3.617-1.22-12.678-.447-16.335c2.723-12.76 12.353-21.659 26.25-24.3c4.51-.853 14.994-.528 19.424.569Z"></path></svg>

================
File: src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: drizzle.config.ts
================
import { config } from 'dotenv';
import { defineConfig } from 'drizzle-kit';

config({ path: '.env' });

export default defineConfig({
  schema: './src/db/schema.ts',
  out: './migrations',
  dialect: 'turso',
  dbCredentials: {
    url: process.env.TURSO_DATABASE_URL!,
    authToken: process.env.TURSO_AUTH_TOKEN!,
  },
});

================
File: elm.json
================
{
    "type": "application",
    "source-directories": [
        "src"
    ],
    "elm-version": "0.19.1",
    "dependencies": {
        "direct": {
            "NoRedInk/elm-json-decode-pipeline": "1.0.1",
            "elm/browser": "1.0.2",
            "elm/core": "1.0.5",
            "elm/html": "1.0.0",
            "elm/json": "1.1.3",
            "jinjor/elm-debounce": "3.0.0"
        },
        "indirect": {
            "elm/time": "1.0.0",
            "elm/url": "1.0.0",
            "elm/virtual-dom": "1.0.3"
        }
    },
    "test-dependencies": {
        "direct": {},
        "indirect": {}
    }
}

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + TS</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>

================
File: package.json
================
{
  "name": "dash",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "drizzle-kit": "^0.30.1",
    "typescript": "~5.6.2",
    "vite": "^6.0.1",
    "vite-plugin-elm": "^3.0.1"
  },
  "dependencies": {
    "@libsql/client": "^0.14.0",
    "autoprefixer": "^10.4.20",
    "dotenv": "^16.4.7",
    "drizzle-orm": "^0.38.2",
    "tailwindcss": "^3.4.16"
  }
}

================
File: postcss.config.cjs
================
module.exports = {
    plugins: [
        require("tailwindcss"),
        require("autoprefixer"),
    ],
};

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx,elm}", // This will include all files in src with these extensions
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

================
File: vite.config.ts
================
import { defineConfig } from 'vite'
import elmPlugin from 'vite-plugin-elm'

export default defineConfig({
  plugins: [elmPlugin()],
  esbuild: {
    loader: 'tsx',
    target: 'esnext'
  }
})
